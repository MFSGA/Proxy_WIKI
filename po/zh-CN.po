#
msgid ""
msgstr ""
"Project-Id-Version: Proxy Wiki\n"
"POT-Creation-Date: 2026-02-10T02:36:56Z\n"
"PO-Revision-Date: 2025-11-08 01:15+0800\n"
"Last-Translator: chimera_rust@proton.me\n"
"Language-Team: Language zh-CN\n"
"Language: zh-CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md
msgid "Summary"
msgstr "目录"

#: src/SUMMARY.md src/preface.md
msgid "Preface"
msgstr "前言"

#: src/SUMMARY.md src/introduction.md
msgid "Introduction"
msgstr "简介"

#: src/SUMMARY.md src/system-topology.md
msgid "System Topology"
msgstr "系统拓扑"

#: src/SUMMARY.md src/chimera_client.md
msgid "Chimera_Client"
msgstr "Chimera_Client"

#: src/SUMMARY.md src/chimera_client/ports.md
msgid "Ports and Listeners"
msgstr "端口与监听器"

#: src/SUMMARY.md src/chimera_client/dns.md
msgid "DNS Module"
msgstr "DNS 模块"

#: src/SUMMARY.md src/chimera_client/tun.md
msgid "Tun Module"
msgstr "Tun 模块"

#: src/SUMMARY.md src/chimera_client/rules.md
msgid "Rule Types and Their Effects"
msgstr "规则类型及其作用"

#: src/SUMMARY.md src/chimera.md
msgid "Chimera Server"
msgstr "Chimera 服务器"

#: src/SUMMARY.md
msgid "Chimera_Server Library"
msgstr "chimera_server 库"

#: src/SUMMARY.md src/protocol.md
msgid "Protocol"
msgstr "协议"

#: src/SUMMARY.md src/protocol.md src/protocols/socks5.md
msgid "SOCKS5"
msgstr "SOCKS5"

#: src/SUMMARY.md src/protocols/http.md
msgid "HTTP"
msgstr "HTTP"

#: src/SUMMARY.md src/protocol.md src/protocols/trojan.md
msgid "Trojan"
msgstr "Trojan"

#: src/SUMMARY.md src/protocols/trojan.md
msgid "Wire Format"
msgstr "报文格式"

#: src/SUMMARY.md src/protocols/trojan.md
msgid "Traffic Handling"
msgstr "流量处理"

#: src/SUMMARY.md src/protocol.md
msgid "Hysteria 2"
msgstr "Hysteria 2"

#: src/SUMMARY.md src/protocol.md src/protocols/tuic.md
msgid "TUIC"
msgstr ""

#: src/SUMMARY.md src/protocol.md src/protocols/vless.md
msgid "VLESS"
msgstr "VLESS"

#: src/SUMMARY.md src/protocol.md src/protocols/xhttp.md
msgid "xHTTP Transport"
msgstr "xHTTP 传输"

#: src/SUMMARY.md src/protocols/reality.md
msgid "Reality"
msgstr ""

#: src/preface.md
msgid ""
"The landscape of proxy applications has become crowded and fragmented, "
"so—out of personal interest—I decided to consolidate the ones I use into a "
"single stack."
msgstr "代理应用的版图已变得拥挤且碎片化，因此——出于个人兴趣——我决定将我使用的那些整合成一个单一的百科全书式的应用。"

#: src/preface.md
#, fuzzy
msgid ""
"`chimera_Client` takes inspiration from the open-source [clash-"
"rs](https://github.com/Watfaq/clash-rs) project, with the long-term goal of "
"matching [Mihomo](https://github.com/MetaCubeX/mihomo)'s feature set."
msgstr ""
"`Chimera_Client` 借鉴了开源 [clash-rs](https://github.com/Watfaq/clash-rs) "
"项目，长期目标是对齐 [Mihomo](https://github.com/MetaCubeX/mihomo) 的功能集。"

#: src/preface.md
msgid ""
"`Chimera` follows the [clash-nyanpasu](https://github.com/libnyanpasu/clash-"
"nyanpasu) project, but the key difference is that my top priority is first-"
"class support for the `chimera_client` engine itself, which can largely be "
"considered the `clash-rs` core."
msgstr ""
"`Chimera` 参考了 [clash-nyanpasu](https://github.com/libnyanpasu/clash-"
"nyanpasu) 项目，但关键区别在于我的首要目标是对 `chimera_client` 引擎本身提供一流支持，它在很大程度上可视为 `clash-"
"rs` 的核心。"

#: src/preface.md
msgid ""
"`Chimera_Server` project can be viewed as a Rust implementation of [xray-"
"core](https://github.com/XTLS/Xray-core), with compatibility with the "
"original `xray-core` remaining the end goal."
msgstr ""
"`Chimera_Server` 项目可视为 [xray-core](https://github.com/XTLS/Xray-core) 的 Rust"
" 实现，并以保持与原版 `xray-core` 兼容为最终目标。"

#: src/preface.md
msgid "Project Links"
msgstr "项目链接"

#: src/preface.md
msgid "`clash-rs`: <https://github.com/Watfaq/clash-rs>"
msgstr "`clash-rs`: <https://github.com/Watfaq/clash-rs>"

#: src/preface.md
msgid "`Mihomo`: <https://github.com/MetaCubeX/mihomo>"
msgstr "`Mihomo`: <https://github.com/MetaCubeX/mihomo>"

#: src/preface.md
msgid "`clash-nyanpasu`: <https://github.com/libnyanpasu/clash-nyanpasu>"
msgstr "`clash-nyanpasu`: <https://github.com/libnyanpasu/clash-nyanpasu>"

#: src/preface.md
msgid "`xray-core`: <https://github.com/XTLS/Xray-core>"
msgstr "`xray-core`: <https://github.com/XTLS/Xray-core>"

#: src/introduction.md
msgid ""
"This documentation set explains the proxy ecosystem maintained in this "
"repository, focusing on three primary projects: `chimera_client`, `Chimera`,"
" and `chimera_server`. Each module targets a different layer of the overall "
"stack—client experience, server-side ingress, and reusable protocol "
"logic—yet they share a common goal: delivering reliable, high-performance "
"connectivity under diverse network conditions. The following chapters "
"describe how the pieces fit together, what problems each component solves, "
"and how teams can deploy and extend them."
msgstr ""
"本文档集介绍本仓库维护的代理生态，重点关注三个主要项目：`chimera_client`、`Chimera` 和 "
"`chimera_server`。每个模块面向整体栈的不同层面——客户端体验、服务端入口以及可复用的协议逻辑——但目标一致：在多样网络条件下提供可靠、高性能的连通性。后续章节将说明各部分如何协作、各自解决的问题，以及团队如何部署和扩展它们。"

#: src/system-topology.md
msgid ""
"The reference deployment pairs `clash-rs` clients with one or multiple "
"`Chimera` frontends, all built on the shared primitives exposed by "
"`chimera_core`. Clients typically run on user devices or edge nodes where "
"they terminate local applications and translate outbound traffic into proxy-"
"aware streams. These streams traverse secure tunnels toward `Chimera`, which"
" performs authentication, routing, and protocol termination before "
"forwarding packets to upstream services or the public internet."
msgstr ""
"参考部署将 `clash-rs` 客户端与一个或多个 `Chimera` 前端配对，二者都构建在`chimera_core` "
"提供的共享原语之上。客户端通常运行在用户设备或边缘节点上，在那里接管本地应用并将出站流量转换为代理可感知的流。随后这些流经由安全隧道到达`Chimera`，后者在转发数据包至上游服务或公网之前完成认证、路由与协议终止。"

#: src/system-topology.md
msgid ""
"Because the stack centers on `chimera_core`, upgrades to cipher suites, "
"multiplexing strategies, or configuration schemas become instantly available"
" to both sides, minimizing version skew. Observability is likewise unified: "
"telemetry emitted at each layer shares identifiers so that request flows "
"remain traceable end to end."
msgstr ""
"由于整个栈以 `chimera_core` "
"为中心，对加密套件、多路复用策略或配置模式的升级会立即在两端生效，最大限度减少版本偏差。可观测性也被统一：各层发出的遥测共享标识符，使请求链路能够端到端追踪。"

#: src/chimera_client.md
msgid "Role and Objectives"
msgstr "角色与目标"

#: src/chimera_client.md
msgid ""
"`chimera_client` is a Rust reimplementation of the popular Clash client, "
"optimized for low-latency rule evaluation and resource-constrained "
"environments. It exposes the familiar Clash configuration language while "
"embracing Rust’s safety guarantees, making it suitable for desktop, mobile "
"(via bindings), and headless automation scenarios. The client focuses on "
"three pillars: broad protocol compatibility, deterministic policy routing, "
"and easy operator ergonomics."
msgstr ""
"`chimera_client` 是流行 Clash 客户端的 Rust 版本重写，针对低延迟规则评估和资源受限环境做了优化。它提供熟悉的 Clash "
"配置语言，同时利用 Rust "
"的安全性保证，适用于桌面、移动端（通过绑定）以及无头自动化场景。客户端聚焦三大支柱：广泛的协议兼容性、确定性的策略路由，以及易用的运维体验。"

#: src/chimera_client.md
msgid "Architecture Overview"
msgstr "架构概览"

#: src/chimera_client.md
msgid ""
"Internally, the client splits into configuration ingestion, controller APIs,"
" transport engines, and policy runtime. The configuration loader parses "
"Clash YAML into strongly typed Rust structures, validates them with "
"`chimera_core` schemas, and hot-reloads updates. The controller layer "
"provides both a local HTTP API and optional TUI, enabling on-device rule "
"inspection. Transport engines encapsulate each supported protocol (e.g., "
"Shadowsocks, VMess, Trojan, Reality/QUIC); they share cipher suites and "
"handshake logic via `chimera_core`. The policy runtime builds a decision "
"tree from user rules, executes DNS strategies, and feeds matching traffic "
"into the appropriate transport engine."
msgstr ""
"在内部，客户端划分为配置导入、控制器 API、传输引擎和策略运行时。配置加载器将Clash YAML 解析为强类型的 Rust 结构，并用 "
"`chimera_core` 的 schema 校验，随后支持热更新。控制器层提供本地 HTTP API 和可选 "
"TUI，使设备端可以检查规则。传输引擎封装每种受支持的协议（如 Shadowsocks、VMess、Trojan、Reality/QUIC），并通过 "
"`chimera_core` 共享加密套件与握手逻辑。策略运行时根据用户规则构建决策树，执行 DNS 策略，将匹配流量交给相应的传输引擎。"

#: src/chimera_client.md
msgid "Module Configuration Guide"
msgstr "模块配置指南"

#: src/chimera_client.md
msgid ""
"`chimera_client` keeps configuration aligned with its module boundaries, so "
"each functional area has its own block in the Clash-style YAML. This makes "
"changes easier to reason about, and limits the blast radius of hot-reload "
"updates."
msgstr ""
"`chimera_client` 将配置与模块边界保持一致，因此每个功能域都有对应的 Clash 风格 YAML "
"配置块。这使改动更易理解，也能限制热更新带来的影响范围。"

#: src/chimera_client.md
msgid ""
"Core runtime and profile: set global defaults such as mode selection, "
"service ports, logging verbosity, IPv6/allow-lan toggles, and reload "
"behavior."
msgstr "核心运行时与配置：设置模式选择、服务端口、日志级别、IPv6/allow-lan 开关以及重载行为等全局默认项。"

#: src/chimera_client.md
msgid ""
"Inbound listeners: define local HTTP/SOCKS/TUN/transparent ports, bind "
"addresses, UDP enablement, and device interface selection. See [Ports and "
"Listeners](./chimera_client/ports.md)."
msgstr ""
"入站监听：定义本地 HTTP/SOCKS/TUN/透明代理端口、绑定地址、UDP "
"开关与设备接口选择。参见[端口与监听器](./chimera_client/ports.md)。"

#: src/chimera_client.md
msgid ""
"Controller and UX: configure the API bind host/port, authentication tokens, "
"and optional TUI or desktop shell toggles."
msgstr "控制器与交互：配置 API 绑定地址/端口、认证令牌，以及可选的 TUI 或桌面外壳开关。"

#: src/chimera_client.md
msgid ""
"DNS pipeline: declare upstream resolvers, cache sizing, fake-IP versus real-"
"IP strategy, fallback behavior, and policy-based resolver selection. See "
"[DNS Module](./chimera_client/dns.md)."
msgstr ""
"DNS 管线：声明上游解析器、缓存大小、fake-IP 与 real-IP 策略、回退行为，以及基于策略的解析器选择。参见[DNS "
"模块](./chimera_client/dns.md)。"

#: src/chimera_client.md
msgid ""
"Policy engine: order rules, attach rule providers, choose a default group, "
"and map traffic to outbound groups. See [Rule Types and Their "
"Effects](./chimera_client/rules.md)."
msgstr ""
"策略引擎：按顺序编排规则、挂载规则提供器、选择默认策略组，并将流量映射到对应出站组。参见[规则类型及其作用](./chimera_client/rules.md)。"

#: src/chimera_client.md
msgid ""
"Transport engines: specify per-protocol parameters like cipher suites, "
"transports (TCP/WS/gRPC/QUIC), multiplexing, and TLS fingerprint options; "
"reuse defaults to keep profiles consistent."
msgstr "传输引擎：按协议设置密码套件、传输层（TCP/WS/gRPC/QUIC）、多路复用与 TLS 指纹选项；尽量复用默认值以保持配置一致性。"

#: src/chimera_client.md
msgid ""
"Observability: enable structured logs, metrics, and trace exports, with "
"sampling and retention tuned per environment."
msgstr "可观测性：启用结构化日志、指标与追踪导出，并按环境调整采样率与保留策略。"

#: src/chimera_client.md
msgid ""
"Update and sync: manage remote profile URLs, signature verification, polling"
" intervals, and rollback on invalid configs."
msgstr "更新与同步：管理远程配置 URL、签名校验、轮询间隔，以及无效配置回滚。"

#: src/chimera_client.md
msgid "Protocol Coverage and Features"
msgstr "当前支持的协议与特性"

#: src/chimera_client.md
msgid ""
"`chimera_client` aims for interoperability with the most common proxy "
"ecosystems:"
msgstr "`chimera_client` 致力于与最常见的代理生态互操作："

#: src/chimera_client.md
msgid "Traditional: HTTP(S), SOCKS5, and TCP/UDP relays."
msgstr "传统：HTTP(S)、SOCKS5，以及 TCP/UDP 中继。"

#: src/chimera_client.md
msgid ""
"Modern encrypted: Shadowsocks/SSR, VMess/VLESS (TCP/WS/gRPC/QUIC), Trojan, "
"NaïveProxy, TUIC, Hysteria v2."
msgstr ""
"现代加密：Shadowsocks/SSR、VMess/VLESS（TCP/WS/gRPC/QUIC）、Trojan、NaïveProxy、TUIC、Hysteria"
" v2。"

#: src/chimera_client.md
msgid ""
"Advanced transports: Reality TLS fingerprinting, multiplexed QUIC sessions, "
"and custom obfuscation plugins."
msgstr "高级传输：Reality TLS 指纹、QUIC 多路复用会话，以及自定义混淆插件。"

#: src/chimera_client.md
msgid ""
"Each protocol implementation documents cipher options, authentication "
"requirements, multiplexing behavior, and fallbacks. Users can mix outbound "
"types in a single configuration and chain proxies for complex routing."
msgstr "每种协议实现都记录加密选项、认证要求、多路复用行为与回退策略。用户可以在同一配置中混用多种出站类型，并串联代理以实现复杂路由。"

#: src/chimera_client.md
msgid "Deployment Patterns"
msgstr "部署模式"

#: src/chimera_client.md
msgid ""
"The client ships binaries for major desktop platforms and offers container "
"images for server-side routing or CI testing. A lightweight system service "
"wraps the daemon on Linux to manage automatic restarts and secret rotation. "
"For mobile, bindings expose the controller API to Flutter and React Native "
"shells. Configuration synchronization relies on GitOps-friendly manifests "
"plus optional remote profile URLs, enabling fleets to pull signed updates on"
" schedule."
msgstr ""
"客户端为主流桌面平台提供二进制，并提供容器镜像用于服务器端路由或 CI 测试。Linux "
"上有轻量级系统服务封装守护进程，负责自动重启与密钥轮换。移动端通过绑定向 Flutter 和 React Native 壳应用暴露控制器 "
"API。配置同步依赖 GitOps 友好的清单与可选的远程配置 URL，使大规模部署能够按计划拉取签名更新。"

#: src/chimera_client.md
msgid "Performance, Observability, and Troubleshooting"
msgstr "性能、可观测性与故障排查"

#: src/chimera_client.md
msgid ""
"`chimera_client` integrates structured logging, OpenTelemetry traces, and "
"per-rule metrics. Operators can export connection stats, latency "
"percentiles, and rule hit counts for dashboards. Performance tuning guidance"
" covers DNS cache sizing, rule tree pruning, per-protocol concurrency caps, "
"and CPU affinity when running on routers. Troubleshooting chapters walk "
"through common failure modes such as TLS fingerprint mismatches, DNS "
"poisoning, or controller authentication errors."
msgstr ""
"`chimera_client` 集成结构化日志、OpenTelemetry "
"追踪和按规则统计的指标。运维人员可以导出连接统计、延迟分位数和规则命中次数用于仪表盘。性能调优指南涵盖 DNS "
"缓存大小、规则树裁剪、各协议并发上限，以及在路由器上运行时的 CPU 亲和性设置。故障排查章节会讲解常见失效场景，如 TLS 指纹不匹配、DNS "
"污染或控制器认证错误。"

#: src/chimera_client.md
msgid "Reference Repositories"
msgstr "参考仓库"

#: src/chimera_client.md
msgid "The `chimera_client` source lives here:"
msgstr "`chimera_client` 源码地址："

#: src/chimera_client.md
msgid "`chimera_client`: <https://github.com/MFSGA/Chimera_Client>"
msgstr "`chimera_client`：<https://github.com/MFSGA/Chimera_Client>"

#: src/chimera_client/ports.md src/chimera_client/rules.md src/protocol.md
#: src/protocols/xhttp.md
msgid "Overview"
msgstr "概览"

#: src/chimera_client/ports.md
msgid ""
"Ports define where local applications, dashboards, and DNS resolvers connect"
" to `chimera_client`. The naming follows Clash-style configuration, while "
"`chimera_client` currently uses underscore keys for the same concepts."
msgstr ""
"端口定义了本地应用、控制面板和 DNS 解析器连接到 `chimera_client` 的入口位置。"
"命名沿用 Clash 风格配置，而 `chimera_client` 当前对同一概念使用下划线风格键名。"

#: src/chimera_client/ports.md
msgid "Port Map"
msgstr "端口映射"

#: src/chimera_client/ports.md
msgid "Clash key"
msgstr "Clash 键名"

#: src/chimera_client/ports.md
msgid "chimera_client key"
msgstr "chimera_client 键名"

#: src/chimera_client/ports.md
msgid "Role"
msgstr "作用"

#: src/chimera_client/ports.md
msgid "`port` / `http-port`"
msgstr "`port` / `http-port`"

#: src/chimera_client/ports.md
msgid "`port`"
msgstr "`port`"

#: src/chimera_client/ports.md
msgid "HTTP CONNECT proxy for browsers and system proxy settings."
msgstr "用于浏览器和系统代理设置的 HTTP CONNECT 代理。"

#: src/chimera_client/ports.md
msgid "`socks-port`"
msgstr "`socks-port`"

#: src/chimera_client/ports.md
msgid "`socks_port`"
msgstr "`socks_port`"

#: src/chimera_client/ports.md
msgid ""
"SOCKS5 proxy for general applications; UDP associate support is optional."
msgstr "面向通用应用的 SOCKS5 代理；UDP Associate 支持为可选项。"

#: src/chimera_client/ports.md
msgid "`mixed-port`"
msgstr "`mixed-port`"

#: src/chimera_client/ports.md
msgid "`mixed_port`"
msgstr "`mixed_port`"

#: src/chimera_client/ports.md
msgid "Combined HTTP + SOCKS5 listener on one port."
msgstr "在同一端口上合并 HTTP + SOCKS5 监听。"

#: src/chimera_client/ports.md
msgid "`redir-port`"
msgstr "`redir-port`"

#: src/chimera_client/ports.md
msgid "`redir_port`"
msgstr "`redir_port`"

#: src/chimera_client/ports.md
msgid "Linux TCP transparent redirect (iptables REDIRECT)."
msgstr "Linux TCP 透明重定向（iptables REDIRECT）。"

#: src/chimera_client/ports.md
msgid "`tproxy-port`"
msgstr "`tproxy-port`"

#: src/chimera_client/ports.md
msgid "`tproxy_port`"
msgstr "`tproxy_port`"

#: src/chimera_client/ports.md
msgid "Linux TPROXY for TCP/UDP transparent proxying."
msgstr "用于 TCP/UDP 透明代理的 Linux TPROXY。"

#: src/chimera_client/ports.md
msgid "`external-controller`"
msgstr "`external-controller`"

#: src/chimera_client/ports.md
msgid "`external_controller`"
msgstr "`external_controller`"

#: src/chimera_client/ports.md
msgid "REST API port for dashboards and automation."
msgstr "供控制面板与自动化使用的 REST API 端口。"

#: src/chimera_client/ports.md
msgid "`dns.listen`"
msgstr "`dns.listen`"

#: src/chimera_client/ports.md
msgid "Local DNS listener for fake-IP or policy DNS."
msgstr "用于 fake-IP 或策略 DNS 的本地 DNS 监听器。"

#: src/chimera_client/ports.md
msgid "What Each Port Does"
msgstr "各端口的作用"

#: src/chimera_client/ports.md
msgid "HTTP proxy port"
msgstr "HTTP 代理端口"

#: src/chimera_client/ports.md
msgid ""
"Accepts HTTP CONNECT requests and plain HTTP proxy traffic. It is the "
"default choice for browsers and OS-level proxy settings."
msgstr ""
"接收 HTTP CONNECT 请求与普通 HTTP 代理流量。它是浏览器和操作系统级代理设置的默认选择。"

#: src/chimera_client/ports.md
msgid "SOCKS5 port"
msgstr "SOCKS5 端口"

#: src/chimera_client/ports.md
msgid ""
"Accepts SOCKS5 connections from applications that speak SOCKS natively. It "
"is commonly used by developer tools and power users."
msgstr ""
"接收原生支持 SOCKS 的应用发起的 SOCKS5 连接。常用于开发者工具和高级用户场景。"

#: src/chimera_client/ports.md
msgid "Mixed port"
msgstr "混合端口"

#: src/chimera_client/ports.md
msgid ""
"Accepts both HTTP and SOCKS5 on a single port. Use this to simplify local "
"proxy configuration when only one port can be configured."
msgstr ""
"在单个端口上同时接收 HTTP 和 SOCKS5。仅能配置一个端口时，可用它简化本地代理设置。"

#: src/chimera_client/ports.md
msgid "Redir port"
msgstr "Redir 端口"

#: src/chimera_client/ports.md
msgid ""
"Used for TCP transparent proxying on Linux via iptables REDIRECT. It only "
"captures TCP and requires kernel-level redirection rules."
msgstr ""
"用于 Linux 上通过 iptables REDIRECT 实现 TCP 透明代理。它仅捕获 TCP，且需要内核级重定向规则。"

#: src/chimera_client/ports.md
msgid "TProxy port"
msgstr "TProxy 端口"

#: src/chimera_client/ports.md
msgid ""
"Used for Linux TPROXY to capture both TCP and UDP. It requires policy "
"routing and `fwmark` rules, and is often paired with TUN or redirection "
"tooling."
msgstr ""
"用于 Linux TPROXY 以同时捕获 TCP 与 UDP。它需要策略路由和 `fwmark` 规则，并常与 TUN 或重定向工具配合。"

#: src/chimera_client/ports.md
msgid "Controller port"
msgstr "控制器端口"

#: src/chimera_client/ports.md
msgid ""
"Exposes the REST API used by dashboards, mobile shells, and automation. Bind"
" it to localhost unless remote access is required."
msgstr ""
"暴露供仪表盘、移动端外壳和自动化使用的 REST API。除非需要远程访问，否则应绑定到 localhost。"

#: src/chimera_client/ports.md
msgid "DNS listen port"
msgstr "DNS 监听端口"

#: src/chimera_client/ports.md
msgid ""
"Accepts DNS queries from the system or from a TUN stack. It is typically "
"paired with fake-IP or split-horizon DNS rules."
msgstr ""
"接收来自系统或 TUN 协议栈的 DNS 查询。通常与 fake-IP 或 split-horizon DNS 规则配套使用。"

#: src/chimera_client/ports.md
msgid "chimera_client Support Notes"
msgstr "chimera_client 支持说明"

#: src/chimera_client/ports.md
msgid ""
"`socks_port` is the only inbound port wired today; UDP associate is "
"currently disabled."
msgstr "目前仅接通 `socks_port` 入站端口；UDP Associate 当前处于禁用状态。"

#: src/chimera_client/ports.md
msgid ""
"`port`, `mixed_port`, `redir_port`, and `tproxy_port` are reserved for "
"compatibility but not yet implemented."
msgstr ""
"`port`、`mixed_port`、`redir_port` 和 `tproxy_port` 为兼容性保留键，但尚未实现。"

#: src/chimera_client/ports.md
msgid ""
"The DNS server and controller listener are under active development; keep "
"them local unless you are testing."
msgstr "DNS 服务器和控制器监听器仍在积极开发中；除测试外请保持本地绑定。"

#: src/chimera_client/ports.md
msgid "Configuration Examples"
msgstr "配置示例"

#: src/chimera_client/ports.md
msgid "Minimal chimera_client"
msgstr "最小化 chimera_client 配置"

#: src/chimera_client/ports.md
msgid "bind_address"
msgstr "bind_address"

#: src/chimera_client/ports.md
msgid "\"127.0.0.1\""
msgstr "\"127.0.0.1\""

#: src/chimera_client/ports.md
msgid "allow_lan"
msgstr "allow_lan"

#: src/chimera_client/ports.md
msgid "socks_port"
msgstr "socks_port"

#: src/chimera_client/ports.md src/chimera_client/dns.md
msgid "dns"
msgstr "dns"

#: src/chimera_client/ports.md src/chimera_client/dns.md
#: src/chimera_client/tun.md
msgid "enable"
msgstr "enable"

#: src/chimera_client/ports.md src/chimera_client/dns.md
msgid "ipv6"
msgstr "ipv6"

#: src/chimera_client/ports.md
msgid "Clash or Mihomo Layout (Reference)"
msgstr "Clash 或 Mihomo 布局（参考）"

#: src/chimera_client/ports.md src/protocols/xhttp.md
msgid "port"
msgstr "port"

#: src/chimera_client/ports.md
msgid "socks-port"
msgstr "socks-port"

#: src/chimera_client/ports.md
msgid "mixed-port"
msgstr "mixed-port"

#: src/chimera_client/ports.md
msgid "redir-port"
msgstr "redir-port"

#: src/chimera_client/ports.md
msgid "tproxy-port"
msgstr "tproxy-port"

#: src/chimera_client/ports.md
msgid "external-controller"
msgstr "external-controller"

#: src/chimera_client/ports.md
msgid "127.0.0.1:9090"
msgstr "127.0.0.1:9090"

#: src/chimera_client/ports.md src/chimera_client/dns.md
msgid "listen"
msgstr "listen"

#: src/chimera_client/ports.md src/chimera_client/dns.md
msgid "127.0.0.1:1053"
msgstr "127.0.0.1:1053"

#: src/chimera_client/dns.md src/chimera_client/tun.md
msgid "Scope and Goals"
msgstr "范围与目标"

#: src/chimera_client/dns.md
msgid ""
"The DNS module is responsible for domain resolution before policy routing. "
"Its goals are predictable rule matching, low latency, and safe resolution "
"under hostile or unreliable networks. Configuration typically lives under a "
"`dns` block in the Clash-style YAML and can be hot-reloaded."
msgstr "DNS 模块负责在策略路由前完成域名解析。其目标是在敌对或不稳定网络下，依然实现可预测的规则命中、低延迟和安全解析。配置通常位于 Clash 风格 YAML 的 `dns` 块中，并支持热重载。"

#: src/chimera_client/dns.md
msgid "Configuration Areas"
msgstr "配置要点"

#: src/chimera_client/dns.md
msgid ""
"Upstream resolvers: define UDP, DoH, or DoT endpoints, and choose which "
"transport is allowed per environment."
msgstr "上游解析器：定义 UDP、DoH 或 DoT 端点，并按环境选择允许的传输方式。"

#: src/chimera_client/dns.md
msgid ""
"Resolution mode: select fake-IP versus real-IP behavior, and configure the "
"fake-IP pool plus domain filters that must bypass synthesis."
msgstr "解析模式：在 fake-IP 与 real-IP 行为间选择，并配置 fake-IP 地址池与必须绕过合成的域名过滤规则。"

#: src/chimera_client/dns.md
msgid ""
"Split-horizon policies: map domain suffixes or rule sets to specific "
"resolvers, including private zones and regional endpoints."
msgstr "分视域策略：将域名后缀或规则集映射到指定解析器，覆盖私有域和区域化端点。"

#: src/chimera_client/dns.md
msgid ""
"Fallback strategy: add fallback resolvers and health checks for blocked, "
"poisoned, or slow upstreams."
msgstr "回退策略：为被阻断、被污染或缓慢的上游添加回退解析器与健康检查。"

#: src/chimera_client/dns.md
msgid ""
"Cache behavior: tune TTL caps, cache size, and prefetch rules to reduce "
"latency without stale answers."
msgstr "缓存行为：调优 TTL 上限、缓存容量和预取规则，在避免陈旧结果的同时降低延迟。"

#: src/chimera_client/dns.md
msgid ""
"Safety controls: enable hosts overrides, blocklists, or ECS avoidance to "
"limit leakage and improve consistency."
msgstr "安全控制：启用 hosts 覆盖、拦截列表或 ECS 规避，以减少泄露并提升一致性。"

#: src/chimera_client/dns.md
msgid ""
"Bootstrap resolvers: keep a small plain DNS list so DoH or DoT endpoints can"
" be resolved without circular dependencies."
msgstr "引导解析器：保留一个小规模明文 DNS 列表，以便 DoH/DoT 端点可在无循环依赖时被解析。"

#: src/chimera_client/dns.md
msgid "Resolution Modes"
msgstr "解析模式"

#: src/chimera_client/dns.md
msgid ""
"Fake-IP mode: synthesizes IPs so traffic can be steered by domain rules even"
" after apps connect by IP. This works best with TUN or transparent proxying "
"but requires careful fake-IP filtering for local or IP-sensitive services."
msgstr "Fake-IP 模式：通过合成 IP，让应用在以 IP 建连后仍可按域名规则分流。该模式在 TUN 或透明代理场景下效果最佳，但需为本地服务或对 IP 敏感的服务精细配置 fake-IP 过滤。"

#: src/chimera_client/dns.md
msgid ""
"Real-IP mode: returns actual addresses to applications, which is simpler for"
" LAN workflows and strict DNS consumers but reduces the ability to enforce "
"domain rules after connection."
msgstr "Real-IP 模式：向应用返回真实地址，更适合局域网流程和严格 DNS 消费者，但会降低连接建立后继续执行域名规则的能力。"

#: src/chimera_client/dns.md
msgid ""
"Hybrid usage: keep fake-IP enabled for general traffic and add explicit "
"fake-IP filters for mDNS, LAN suffixes, or time sync domains."
msgstr "混合用法：对通用流量启用 fake-IP，同时为 mDNS、局域网后缀或时间同步域名添加显式 fake-IP 过滤。"

#: src/chimera_client/dns.md
msgid "Resolver Selection Flow"
msgstr "解析器选择流程"

#: src/chimera_client/dns.md
msgid "Apply hosts overrides and consult the in-memory cache."
msgstr "先应用 hosts 覆盖规则，并查询内存缓存。"

#: src/chimera_client/dns.md
msgid "Select a resolver based on domain policies or rule sets."
msgstr "根据域名策略或规则集选择解析器。"

#: src/chimera_client/dns.md
msgid "Query primary resolvers in order or in parallel."
msgstr "按顺序或并行查询主解析器。"

#: src/chimera_client/dns.md
msgid "If responses fail validation or time out, trigger fallback resolvers."
msgstr "若响应校验失败或超时，则触发回退解析器。"

#: src/chimera_client/dns.md
msgid "Cache the response with TTL caps and return it to the caller."
msgstr "按 TTL 上限缓存响应并返回给调用方。"

#: src/chimera_client/dns.md
msgid "Configuration References"
msgstr "配置参考"

#: src/chimera_client/dns.md
msgid "chimera_client (current)"
msgstr "chimera_client（当前）"

#: src/chimera_client/dns.md
msgid ""
"The current implementation relies on the system resolver. Keep DNS disabled "
"unless you are testing the in-progress DNS server, and override IPv6 only if"
" you need to suppress AAAA answers."
msgstr "当前实现依赖系统解析器。除非你在测试开发中的 DNS 服务器，否则请保持 DNS 关闭；仅在需要抑制 AAAA 响应时再覆写 IPv6。"

#: src/chimera_client/dns.md
msgid "Mihomo / Clash (reference projects)"
msgstr "Mihomo / Clash（参考项目）"

#: src/chimera_client/dns.md
msgid ""
"This block mirrors the Clash-compatible DNS schema as used by Mihomo. It is "
"usable in those projects and serves as a target shape for chimera_client "
"parity."
msgstr "该配置块复刻了 Mihomo 使用的 Clash 兼容 DNS 结构。它可直接用于这些项目，也作为 chimera_client 对齐的目标形态。"

#: src/chimera_client/dns.md
msgid "enhanced-mode"
msgstr "enhanced-mode"

#: src/chimera_client/dns.md
msgid "fake-ip"
msgstr "fake-ip"

#: src/chimera_client/dns.md
msgid "fake-ip-range"
msgstr "fake-ip-range"

#: src/chimera_client/dns.md
msgid "198.18.0.1/16"
msgstr "198.18.0.1/16"

#: src/chimera_client/dns.md
msgid "fake-ip-filter"
msgstr "fake-ip-filter"

#: src/chimera_client/dns.md
msgid "\"*.lan\""
msgstr "\"*.lan\""

#: src/chimera_client/dns.md
msgid "\"*.local\""
msgstr "\"*.local\""

#: src/chimera_client/dns.md
msgid "default-nameserver"
msgstr "default-nameserver"

#: src/chimera_client/dns.md
msgid "nameserver"
msgstr "nameserver"

#: src/chimera_client/dns.md
msgid "https://dns.alidns.com/dns-query"
msgstr "https://dns.alidns.com/dns-query"

#: src/chimera_client/dns.md
msgid "tls://1.1.1.1:853"
msgstr "tls://1.1.1.1:853"

#: src/chimera_client/dns.md
msgid "fallback"
msgstr "fallback"

#: src/chimera_client/dns.md
msgid "fallback-filter"
msgstr "fallback-filter"

#: src/chimera_client/dns.md
msgid "geoip"
msgstr "geoip"

#: src/chimera_client/dns.md
msgid "geoip-code"
msgstr "geoip-code"

#: src/chimera_client/dns.md
msgid "CN"
msgstr "CN"

#: src/chimera_client/dns.md
msgid "Operational Guidance"
msgstr "实操建议"

#: src/chimera_client/dns.md
msgid ""
"Prefer explicit resolver policies when different traffic classes require "
"distinct egress paths."
msgstr "当不同流量类别需要不同出口路径时，优先使用显式解析器策略。"

#: src/chimera_client/dns.md
msgid ""
"Keep fake-IP exclusions narrow to avoid bypassing rule evaluation "
"unintentionally."
msgstr "保持 fake-IP 排除范围尽量精确，避免无意绕过规则评估。"

#: src/chimera_client/dns.md
msgid ""
"Use a small bootstrap resolver list for DoH or DoT endpoints that must "
"resolve at startup."
msgstr "为必须在启动时解析的 DoH/DoT 端点，配置一个小规模引导解析器列表。"

#: src/chimera_client/dns.md
msgid ""
"Tune cache caps with observed traffic patterns rather than using defaults "
"blindly."
msgstr "应基于观测到的流量模式调优缓存上限，而非盲目使用默认值。"

#: src/chimera_client/dns.md
msgid ""
"Monitor fallback usage; spikes often indicate upstream blocks or transport "
"failures."
msgstr "监控回退使用率；突增通常意味着上游被封锁或传输失败。"

#: src/chimera_client/dns.md src/chimera_client/tun.md src/protocols/xhttp.md
msgid "Troubleshooting Checklist"
msgstr "故障排查清单"

#: src/chimera_client/dns.md
msgid ""
"Confirm the local DNS listener is reachable (for example, `dig @127.0.0.1 -p"
" 1053 example.com`)."
msgstr "确认本地 DNS 监听器可达（例如：`dig @127.0.0.1 -p 1053 example.com`）。"

#: src/chimera_client/dns.md
msgid ""
"Verify the system resolver or TUN stack actually points at the client "
"listener."
msgstr "确认系统解析器或 TUN 协议栈确实指向客户端监听器。"

#: src/chimera_client/dns.md
msgid "Revisit fake-IP filters for domains that must keep real IPs."
msgstr "对必须保留真实 IP 的域名，重新检查 fake-IP 过滤规则。"

#: src/chimera_client/dns.md
msgid ""
"Inspect logs for upstream timeouts, TLS handshake errors, or poisoned "
"responses."
msgstr "检查日志中是否存在上游超时、TLS 握手错误或污染响应。"

#: src/chimera_client/dns.md
msgid ""
"Temporarily force a single UDP resolver to isolate DoH or DoT connectivity "
"issues."
msgstr "可临时强制使用单一 UDP 解析器，以隔离 DoH/DoT 连通性问题。"

#: src/chimera_client/tun.md
msgid ""
"TUN mode captures Layer-3 traffic from the host and sends it into the proxy "
"pipeline without requiring each application to be proxy-aware. Compared with"
" HTTP/SOCKS listeners, TUN is the closest to \"system-wide proxy\" behavior "
"and is usually combined with policy routing and DNS control."
msgstr "TUN 模式会捕获主机的三层流量，并将其送入代理管线，无需每个应用具备代理能力。相比 HTTP/SOCKS 监听器，TUN 最接近“系统级代理”行为，通常与策略路由和 DNS 控制联合使用。"

#: src/chimera_client/tun.md
msgid ""
"This page follows `clash-rs` semantics and config keys so future "
"`chimera_client` parity is straightforward."
msgstr "本页遵循 `clash-rs` 的语义与配置键，以便后续 `chimera_client` 对齐更加直接。"

#: src/chimera_client/tun.md
msgid "Current Project Status"
msgstr "当前项目状态"

#: src/chimera_client/tun.md
msgid ""
"`chimera_client` (current mainline) does not yet expose a `tun` block in its"
" config parser."
msgstr "`chimera_client`（当前主线）在配置解析器中尚未暴露 `tun` 配置块。"

#: src/chimera_client/tun.md
msgid ""
"The TUN section below is the clash-rs-aligned target shape and operational "
"guidance, not a statement that all fields are already active in "
"`chimera_client`."
msgstr "下方 TUN 章节是与 clash-rs 对齐的目标形态和运维指引，不代表 `chimera_client` 中所有字段都已生效。"

#: src/chimera_client/tun.md
msgid ""
"Today, use SOCKS/listener-based workflows in `chimera_client` unless you are"
" validating an in-progress TUN branch."
msgstr "当前建议在 `chimera_client` 中使用基于 SOCKS/监听器的工作流，除非你正在验证开发中的 TUN 分支。"

#: src/chimera_client/tun.md
msgid "Configuration Schema (Clash-rs Aligned)"
msgstr "配置结构（与 Clash-rs 对齐）"

#: src/chimera_client/tun.md
msgid "tun"
msgstr "tun"

#: src/chimera_client/tun.md
msgid "device-id"
msgstr "device-id"

#: src/chimera_client/tun.md
msgid "\"dev://utun1989\""
msgstr "\"dev://utun1989\""

#: src/chimera_client/tun.md
msgid "route-all"
msgstr "route-all"

#: src/chimera_client/tun.md
msgid "gateway"
msgstr "gateway"

#: src/chimera_client/tun.md
msgid "\"198.18.0.1/24\""
msgstr "\"198.18.0.1/24\""

#: src/chimera_client/tun.md
msgid "gateway-v6"
msgstr "gateway-v6"

#: src/chimera_client/tun.md
msgid "\"fd00:fac::1/64\""
msgstr "\"fd00:fac::1/64\""

#: src/chimera_client/tun.md
msgid "mtu"
msgstr "mtu"

#: src/chimera_client/tun.md
msgid "so-mark"
msgstr "so-mark"

#: src/chimera_client/tun.md
msgid "route-table"
msgstr "route-table"

#: src/chimera_client/tun.md
msgid "dns-hijack"
msgstr "dns-hijack"

#: src/chimera_client/tun.md
msgid ""
"# dns-hijack:\n"
"  #   - 1.1.1.1:53\n"
"  #   - 8.8.8.8:53\n"
"  # routes:\n"
"  #   - 1.1.1.1/32\n"
"  #   - 2001:4860:4860::8888/128\n"
msgstr "# dns-hijack:\n  #   - 1.1.1.1:53\n  #   - 8.8.8.8:53\n  # routes:\n  #   - 1.1.1.1/32\n  #   - 2001:4860:4860::8888/128\n"

#: src/chimera_client/tun.md
msgid "Key Fields and Semantics"
msgstr "关键字段与语义"

#: src/chimera_client/tun.md
msgid "Key"
msgstr "键名"

#: src/chimera_client/tun.md
msgid "Type"
msgstr "类型"

#: src/chimera_client/tun.md
msgid "Default"
msgstr "默认值"

#: src/chimera_client/tun.md src/protocols/trojan/wire-format.md
msgid "Notes"
msgstr "注意事项"

#: src/chimera_client/tun.md
msgid "`enable`"
msgstr "`enable`"

#: src/chimera_client/tun.md
msgid "`bool`"
msgstr "`bool`"

#: src/chimera_client/tun.md
msgid "`false`"
msgstr "`false`"

#: src/chimera_client/tun.md
msgid "Enables TUN runtime."
msgstr "启用 TUN 运行时。"

#: src/chimera_client/tun.md
msgid "`device-id`"
msgstr "`device-id`"

#: src/chimera_client/tun.md
msgid "`string`"
msgstr "`string`"

#: src/chimera_client/tun.md
msgid "`utun1989`"
msgstr "`utun1989`"

#: src/chimera_client/tun.md
msgid ""
"Accepts `dev://<name>`, `fd://<n>`, or plain name (treated as device name)."
msgstr "支持 `dev://<name>`、`fd://<n>` 或纯名称（按设备名处理）。"

#: src/chimera_client/tun.md
msgid "`gateway`"
msgstr "`gateway`"

#: src/chimera_client/tun.md
msgid "`CIDR string`"
msgstr "`CIDR string`"

#: src/chimera_client/tun.md
msgid "`198.18.0.1/24`"
msgstr "`198.18.0.1/24`"

#: src/chimera_client/tun.md
msgid "IPv4 address/prefix assigned to the TUN interface."
msgstr "分配给 TUN 接口的 IPv4 地址/前缀。"

#: src/chimera_client/tun.md
msgid "`gateway-v6`"
msgstr "`gateway-v6`"

#: src/chimera_client/tun.md
msgid "unset"
msgstr "未设置"

#: src/chimera_client/tun.md
msgid "Optional IPv6 address/prefix for dual-stack TUN."
msgstr "双栈 TUN 的可选 IPv6 地址/前缀。"

#: src/chimera_client/tun.md
msgid "`route-all`"
msgstr "`route-all`"

#: src/chimera_client/tun.md
msgid "Route all host traffic through TUN."
msgstr "将主机全部流量通过 TUN 路由。"

#: src/chimera_client/tun.md
msgid "`routes`"
msgstr "`routes`"

#: src/chimera_client/tun.md
msgid "`list<CIDR>`"
msgstr "`list<CIDR>`"

#: src/chimera_client/tun.md
msgid "empty"
msgstr "空"

#: src/chimera_client/tun.md
msgid "Used when `route-all: false` to route only selected prefixes."
msgstr "在 `route-all: false` 时使用，仅路由选定前缀。"

#: src/chimera_client/tun.md
msgid "`mtu`"
msgstr "`mtu`"

#: src/chimera_client/tun.md
msgid "`u16`"
msgstr "`u16`"

#: src/chimera_client/tun.md
msgid "platform default"
msgstr "平台默认值"

#: src/chimera_client/tun.md
msgid "Runtime uses `1500` by default (`65535` on Windows) if unset."
msgstr "若未设置，运行时默认使用 `1500`（Windows 为 `65535`）。"

#: src/chimera_client/tun.md
msgid "`so-mark`"
msgstr "`so-mark`"

#: src/chimera_client/tun.md
msgid "`u32`"
msgstr "`u32`"

#: src/chimera_client/tun.md
msgid "Linux fwmark for loop prevention / policy routing integration."
msgstr "Linux fwmark，用于防环路和策略路由集成。"

#: src/chimera_client/tun.md
msgid "`route-table`"
msgstr "`route-table`"

#: src/chimera_client/tun.md
msgid "`2468`"
msgstr "`2468`"

#: src/chimera_client/tun.md
msgid "Linux policy-routing table used by TUN route-all path."
msgstr "TUN 全局路由路径使用的 Linux 策略路由表。"

#: src/chimera_client/tun.md
msgid "`dns-hijack`"
msgstr "`dns-hijack`"

#: src/chimera_client/tun.md
msgid "`bool` or `list`"
msgstr "`bool` 或 `list`"

#: src/chimera_client/tun.md
msgid "Enables DNS interception behavior in TUN path."
msgstr "在 TUN 路径中启用 DNS 劫持行为。"

#: src/chimera_client/tun.md
msgid "Device-ID Formats"
msgstr "Device-ID 格式"

#: src/chimera_client/tun.md
msgid "`dev://utun1989` or `utun1989`: create/use named TUN device."
msgstr "`dev://utun1989` 或 `utun1989`：创建/使用具名 TUN 设备。"

#: src/chimera_client/tun.md
msgid "`dev://tun0`: common Linux style."
msgstr "`dev://tun0`：常见 Linux 写法。"

#: src/chimera_client/tun.md
msgid ""
"`fd://3`: use an existing file descriptor, useful when another component "
"owns TUN creation."
msgstr "`fd://3`：使用现有文件描述符，适用于由其他组件创建 TUN 的场景。"

#: src/chimera_client/tun.md
msgid "On macOS, the device name must use the `utun` prefix."
msgstr "在 macOS 上，设备名必须使用 `utun` 前缀。"

#: src/chimera_client/tun.md
msgid "Routing Behavior"
msgstr "路由行为"

#: src/chimera_client/tun.md
msgid "`route-all: true`"
msgstr "`route-all: true`"

#: src/chimera_client/tun.md
msgid ""
"Linux: uses policy routing rules and a dedicated route table (`route-"
"table`)."
msgstr "Linux：使用策略路由规则和独立路由表（`route-table`）。"

#: src/chimera_client/tun.md
msgid "macOS/Windows: installs broad default-route entries through TUN."
msgstr "macOS/Windows：通过 TUN 安装较宽泛的默认路由项。"

#: src/chimera_client/tun.md
msgid ""
"DNS hijack integration is tied to this path on Linux (policy rule for "
"destination port `53`)."
msgstr "在 Linux 上，DNS 劫持集成绑定于该路径（目标端口 `53` 的策略规则）。"

#: src/chimera_client/tun.md
msgid "`route-all: false`"
msgstr "`route-all: false`"

#: src/chimera_client/tun.md
msgid "Only CIDRs in `routes` are routed through TUN."
msgstr "仅 `routes` 中的 CIDR 会通过 TUN 路由。"

#: src/chimera_client/tun.md
msgid ""
"This is safer for partial rollout and avoids taking over all host traffic."
msgstr "这更适合分阶段上线，并避免接管主机全部流量。"

#: src/chimera_client/tun.md
msgid "If both are configured, `route-all` takes precedence operationally."
msgstr "若两者同时配置，运行时以 `route-all` 为准。"

#: src/chimera_client/tun.md
msgid "DNS Interaction"
msgstr "DNS 交互"

#: src/chimera_client/tun.md
msgid ""
"`dns-hijack` controls DNS interception in TUN flow, but it does not replace "
"a working DNS module config."
msgstr "`dns-hijack` 控制 TUN 流中的 DNS 劫持，但它不能替代可工作的 DNS 模块配置。"

#: src/chimera_client/tun.md
msgid ""
"For predictable domain-based routing, pair TUN with DNS settings "
"(`dns.enable`, resolver list, fake-IP strategy where needed)."
msgstr "要获得可预测的基于域名路由效果，应将 TUN 与 DNS 设置（`dns.enable`、解析器列表、按需 fake-IP 策略）配套使用。"

#: src/chimera_client/tun.md
msgid ""
"In practice, `dns-hijack: true` is commonly paired with fake-IP mode in "
"Clash-style deployments."
msgstr "在实践中，Clash 风格部署通常将 `dns-hijack: true` 与 fake-IP 模式搭配使用。"

#: src/chimera_client/tun.md
msgid "Linux Notes (Policy Routing)"
msgstr "Linux 注意事项（策略路由）"

#: src/chimera_client/tun.md
msgid "Ensure `iproute2` (`ip` command) is available."
msgstr "确保已安装 `iproute2`（`ip` 命令可用）。"

#: src/chimera_client/tun.md
msgid "Run with sufficient privileges (CAP_NET_ADMIN or root-equivalent)."
msgstr "以足够权限运行（CAP_NET_ADMIN 或等效 root 权限）。"

#: src/chimera_client/tun.md
msgid ""
"Prefer setting `so-mark` and keep it consistent with your external policy "
"rules to avoid proxy loops."
msgstr "建议设置 `so-mark`，并与外部策略规则保持一致，以避免代理环路。"

#: src/chimera_client/tun.md
msgid "Quick checks:"
msgstr "快速检查："

#: src/chimera_client/tun.md
msgid "Example Profiles"
msgstr "示例配置"

#: src/chimera_client/tun.md
msgid "Full-tunnel profile"
msgstr "全隧道配置"

#: src/chimera_client/tun.md
msgid "Split-route profile"
msgstr "分流配置"

#: src/chimera_client/tun.md
msgid "\"dev://tun0\""
msgstr "\"dev://tun0\""

#: src/chimera_client/tun.md
msgid "routes"
msgstr "routes"

#: src/chimera_client/tun.md
msgid "1.1.1.1/32"
msgstr "1.1.1.1/32"

#: src/chimera_client/tun.md
msgid "8.8.8.8/32"
msgstr "8.8.8.8/32"

#: src/chimera_client/tun.md
msgid "FD-based profile"
msgstr "基于 FD 的配置"

#: src/chimera_client/tun.md
msgid "\"fd://3\""
msgstr "\"fd://3\""

#: src/chimera_client/tun.md
msgid ""
"Verify process privileges first; TUN creation and route changes fail "
"silently in many restricted environments."
msgstr "先确认进程权限；在许多受限环境中，TUN 创建和路由变更会静默失败。"

#: src/chimera_client/tun.md
msgid ""
"Confirm the interface exists (`ip addr`, `ifconfig`, or platform "
"equivalent)."
msgstr "确认接口已存在（`ip addr`、`ifconfig` 或平台等效命令）。"

#: src/chimera_client/tun.md
msgid "Validate route/rule installation after startup."
msgstr "启动后验证路由/规则是否正确安装。"

#: src/chimera_client/tun.md
msgid ""
"If DNS appears broken, verify the DNS listener is reachable and the system "
"resolver path actually passes through TUN."
msgstr "若 DNS 异常，请确认 DNS 监听器可达，且系统解析路径确实经过 TUN。"

#: src/chimera_client/tun.md
msgid ""
"If traffic loops or stalls, check `so-mark`/policy-rule alignment and "
"existing host firewall rules."
msgstr "若流量出现环路或卡顿，请检查 `so-mark`/策略规则的一致性以及主机现有防火墙规则。"

#: src/chimera_client/tun.md
msgid "References and Alignment Notes"
msgstr "参考与对齐说明"

#: src/chimera_client/tun.md
msgid ""
"Clash-rs config schema: `clash-lib/src/config/def.rs` (`TunConfig`, "
"defaults, `dns-hijack` shape)."
msgstr "Clash-rs 配置结构：`clash-lib/src/config/def.rs`（`TunConfig`、默认值、`dns-hijack` 形态）。"

#: src/chimera_client/tun.md
msgid ""
"Clash-rs config conversion: `clash-lib/src/config/internal/convert/tun.rs`."
msgstr "Clash-rs 配置转换：`clash-lib/src/config/internal/convert/tun.rs`。"

#: src/chimera_client/tun.md
msgid ""
"Clash-rs tun runtime and device parsing: `clash-"
"lib/src/proxy/tun/inbound.rs`."
msgstr "Clash-rs TUN 运行时与设备解析：`clash-lib/src/proxy/tun/inbound.rs`。"

#: src/chimera_client/tun.md
msgid ""
"Clash-rs route behavior: `clash-"
"lib/src/proxy/tun/routes/{linux,macos,windows}.rs`."
msgstr "Clash-rs 路由行为：`clash-lib/src/proxy/tun/routes/{linux,macos,windows}.rs`。"

#: src/chimera_client/tun.md
msgid "Clash-rs sample profile: `clash-bin/tests/data/config/tun.yaml`."
msgstr "Clash-rs 示例配置：`clash-bin/tests/data/config/tun.yaml`。"

#: src/chimera_client/tun.md
msgid ""
"Chimera_Client current parser snapshot: `clash-lib/src/config/def.rs` (no "
"`tun` block yet on mainline)."
msgstr "Chimera_Client 当前解析器快照：`clash-lib/src/config/def.rs`（主线尚无 `tun` 配置块）。"

#: src/chimera_client/rules.md
msgid ""
"In `chimera_client`, rules decide **which outbound group** a flow should "
"use. Rules are matched **top to bottom**, and the first matched rule wins. "
"Place highly specific rules first, and broad fallback rules near the end."
msgstr ""
"在 `chimera_client` "
"中，规则用于决定流量应使用**哪个出站组**。规则按**自上而下**顺序匹配，命中即停止。应将高特异性的规则放在前面，将宽泛的兜底规则放在后面。"

#: src/chimera_client/rules.md
msgid "Rule Evaluation Basics"
msgstr "规则匹配基础"

#: src/chimera_client/rules.md
msgid "First-match-wins: once a rule matches, later rules are ignored."
msgstr "首条命中优先：一旦规则命中，后续规则将被忽略。"

#: src/chimera_client/rules.md
msgid ""
"Input signals: domain (SNI/Host), resolved IP, destination port, process "
"name/path, network type, and GeoIP/GeoSite datasets."
msgstr "输入信号包括：域名（SNI/Host）、解析后的 IP、目标端口、进程名/路径、网络类型，以及 GeoIP/GeoSite 数据集。"

#: src/chimera_client/rules.md
msgid ""
"Common action: route to a policy group such as `DIRECT`, `REJECT`, `Proxy`, "
"or `Auto`."
msgstr "常见动作：将流量路由到策略组，例如 `DIRECT`、`REJECT`、`Proxy` 或 `Auto`。"

#: src/chimera_client/rules.md
msgid "Common Domain Rules"
msgstr "常见域名规则"

#: src/chimera_client/rules.md
msgid "`DOMAIN`"
msgstr ""

#: src/chimera_client/rules.md
msgid "Matches an exact domain name."
msgstr "匹配精确域名。"

#: src/chimera_client/rules.md
msgid "Use when:"
msgstr "适用场景："

#: src/chimera_client/rules.md
msgid "You want strict and deterministic matching for a single host."
msgstr "你希望对单个主机进行严格且确定性的匹配。"

#: src/chimera_client/rules.md
msgid "Example:"
msgstr "示例："

#: src/chimera_client/rules.md
msgid "rules"
msgstr ""

#: src/chimera_client/rules.md
msgid "DOMAIN,api.github.com,Proxy"
msgstr ""

#: src/chimera_client/rules.md
msgid "`DOMAIN-SUFFIX`"
msgstr ""

#: src/chimera_client/rules.md
msgid "Matches a domain suffix, including subdomains."
msgstr "匹配域名后缀（包含子域名）。"

#: src/chimera_client/rules.md
msgid "You need to route an entire service namespace."
msgstr "你需要对整个服务域名空间进行路由。"

#: src/chimera_client/rules.md
msgid "DOMAIN-SUFFIX,google.com,Proxy"
msgstr ""

#: src/chimera_client/rules.md
msgid "`DOMAIN-KEYWORD`"
msgstr ""

#: src/chimera_client/rules.md
msgid "Matches domains containing a keyword."
msgstr "匹配包含指定关键字的域名。"

#: src/chimera_client/rules.md
msgid "Service domains are scattered and suffix rules are inconvenient."
msgstr "当服务域名分散、使用后缀规则不方便时。"

#: src/chimera_client/rules.md
msgid "Caution:"
msgstr "注意："

#: src/chimera_client/rules.md
msgid "Overmatching risk is higher than `DOMAIN` / `DOMAIN-SUFFIX`."
msgstr "相比 `DOMAIN` / `DOMAIN-SUFFIX`，它更容易误匹配。"

#: src/chimera_client/rules.md
msgid "DOMAIN-KEYWORD,openai,Proxy"
msgstr ""

#: src/chimera_client/rules.md
msgid "IP and Network Rules"
msgstr "IP 与网络规则"

#: src/chimera_client/rules.md
msgid "`IP-CIDR`"
msgstr ""

#: src/chimera_client/rules.md
msgid "Matches destination IPv4 CIDR blocks."
msgstr "匹配目标 IPv4 CIDR 网段。"

#: src/chimera_client/rules.md
msgid "You need deterministic routing independent of domain names."
msgstr "你需要不依赖域名的确定性路由。"

#: src/chimera_client/rules.md
msgid "IP-CIDR,1.1.1.0/24,DIRECT"
msgstr ""

#: src/chimera_client/rules.md
msgid "`IP-CIDR6`"
msgstr ""

#: src/chimera_client/rules.md
msgid "Matches destination IPv6 CIDR blocks."
msgstr "匹配目标 IPv6 CIDR 网段。"

#: src/chimera_client/rules.md
msgid "Your environment is dual-stack and IPv6 needs explicit policy."
msgstr "你的环境是双栈网络，并且 IPv6 需要显式策略。"

#: src/chimera_client/rules.md
msgid "IP-CIDR6,2606:4700::/32,DIRECT"
msgstr ""

#: src/chimera_client/rules.md
msgid "`SRC-IP-CIDR`"
msgstr ""

#: src/chimera_client/rules.md
msgid "Matches source IP CIDR (useful in gateway/router mode)."
msgstr "匹配源 IP CIDR（在网关/路由器模式下很有用）。"

#: src/chimera_client/rules.md
msgid "Different LAN clients should use different egress paths."
msgstr "不同局域网客户端应走不同的出口路径。"

#: src/chimera_client/rules.md
msgid "SRC-IP-CIDR,192.168.50.0/24,GameProxy"
msgstr ""

#: src/chimera_client/rules.md
msgid "`GEOIP`"
msgstr ""

#: src/chimera_client/rules.md
msgid "Matches destination IP by country/region code via GeoIP database."
msgstr "通过 GeoIP 数据库按国家/地区代码匹配目标 IP。"

#: src/chimera_client/rules.md
msgid "You want country-based traffic splitting."
msgstr "你希望按国家/地区进行分流。"

#: src/chimera_client/rules.md
msgid "GEOIP,CN,DIRECT"
msgstr ""

#: src/chimera_client/rules.md
msgid "`GEOSITE`"
msgstr ""

#: src/chimera_client/rules.md
msgid "Matches domain sets from curated geosite categories."
msgstr "匹配维护好的 geosite 分类域名集合。"

#: src/chimera_client/rules.md
msgid ""
"You prefer maintained domain lists (e.g. `geolocation-!cn`, `category-ads-"
"all`)."
msgstr "你希望使用可维护的域名列表（如 `geolocation-!cn`、`category-ads-all`）。"

#: src/chimera_client/rules.md
msgid "GEOSITE,geolocation-!cn,Proxy"
msgstr ""

#: src/chimera_client/rules.md
msgid "Port and Process Rules"
msgstr "端口与进程规则"

#: src/chimera_client/rules.md
msgid "`DST-PORT`"
msgstr ""

#: src/chimera_client/rules.md
msgid "Matches destination port."
msgstr "匹配目标端口。"

#: src/chimera_client/rules.md
msgid "You need service-type routing (e.g., game ports, custom app ports)."
msgstr "你需要按服务类型分流（如游戏端口、自定义应用端口）。"

#: src/chimera_client/rules.md
msgid "DST-PORT,443,Proxy"
msgstr ""

#: src/chimera_client/rules.md
msgid "`SRC-PORT`"
msgstr ""

#: src/chimera_client/rules.md
msgid "Matches source port."
msgstr "匹配源端口。"

#: src/chimera_client/rules.md
msgid ""
"A local application uses fixed source ports and requires special handling."
msgstr "当本地应用使用固定源端口并需要特殊处理时。"

#: src/chimera_client/rules.md
msgid "SRC-PORT,60000-60100,DIRECT"
msgstr ""

#: src/chimera_client/rules.md
msgid "`PROCESS-NAME`"
msgstr ""

#: src/chimera_client/rules.md
msgid "Matches executable name."
msgstr "匹配可执行文件名。"

#: src/chimera_client/rules.md
msgid "Desktop scenario requires per-app split routing."
msgstr "桌面场景下需要按应用分流。"

#: src/chimera_client/rules.md
msgid "PROCESS-NAME,Telegram.exe,Proxy"
msgstr ""

#: src/chimera_client/rules.md
msgid "`PROCESS-PATH`"
msgstr ""

#: src/chimera_client/rules.md
msgid "Matches full executable path."
msgstr "匹配可执行文件完整路径。"

#: src/chimera_client/rules.md
msgid "You need stronger process-level precision than `PROCESS-NAME`."
msgstr "你需要比 `PROCESS-NAME` 更高的进程级匹配精度。"

#: src/chimera_client/rules.md
msgid "PROCESS-PATH,/Applications/Discord.app/Contents/MacOS/Discord,Proxy"
msgstr ""

#: src/chimera_client/rules.md
msgid "Logical and Provider Rules"
msgstr "逻辑与规则提供器规则"

#: src/chimera_client/rules.md
msgid "`RULE-SET`"
msgstr ""

#: src/chimera_client/rules.md
msgid "References an external provider-defined rule collection."
msgstr "引用外部规则提供器定义的规则集合。"

#: src/chimera_client/rules.md
msgid "You want centralized, auto-updated policy sets."
msgstr "你希望使用集中管理且可自动更新的策略集合。"

#: src/chimera_client/rules.md
msgid "rule-providers"
msgstr ""

#: src/chimera_client/rules.md
msgid "streaming"
msgstr ""

#: src/chimera_client/rules.md src/protocols/xhttp.md
msgid "type"
msgstr ""

#: src/chimera_client/rules.md
msgid "http"
msgstr ""

#: src/chimera_client/rules.md
msgid "behavior"
msgstr ""

#: src/chimera_client/rules.md
msgid "domain"
msgstr ""

#: src/chimera_client/rules.md
msgid "url"
msgstr ""

#: src/chimera_client/rules.md
msgid "https://example.com/streaming.yaml"
msgstr ""

#: src/chimera_client/rules.md
msgid "interval"
msgstr ""

#: src/chimera_client/rules.md src/protocols/xhttp.md
msgid "path"
msgstr ""

#: src/chimera_client/rules.md
msgid "./ruleset/streaming.yaml"
msgstr ""

#: src/chimera_client/rules.md
msgid "RULE-SET,streaming,Proxy"
msgstr ""

#: src/chimera_client/rules.md
msgid "`MATCH`"
msgstr ""

#: src/chimera_client/rules.md
msgid "Catch-all fallback rule."
msgstr "全量兜底规则。"

#: src/chimera_client/rules.md
msgid "You need a deterministic default action for unmatched traffic."
msgstr "你需要为未命中流量设置确定性的默认动作。"

#: src/chimera_client/rules.md
msgid "MATCH,DIRECT"
msgstr ""

#: src/chimera_client/rules.md
msgid "Practical Ordering Template"
msgstr "实用排序模板"

#: src/chimera_client/rules.md
msgid "A practical order is:"
msgstr "推荐的排序如下："

#: src/chimera_client/rules.md
msgid ""
"Hard blocks / safe bypass (`REJECT`, `DIRECT` for local or private ranges)."
msgstr "硬阻断 / 安全直连（本地或私网地址使用 `REJECT`、`DIRECT`）。"

#: src/chimera_client/rules.md
msgid "Precise business rules (`DOMAIN`, `PROCESS-PATH`, `IP-CIDR`)."
msgstr "精确业务规则（`DOMAIN`、`PROCESS-PATH`、`IP-CIDR`）。"

#: src/chimera_client/rules.md
msgid "Curated sets (`GEOSITE`, `RULE-SET`)."
msgstr "维护型集合（`GEOSITE`、`RULE-SET`）。"

#: src/chimera_client/rules.md
msgid "Broad heuristics (`DOMAIN-KEYWORD`, `GEOIP`)."
msgstr "宽泛启发式规则（`DOMAIN-KEYWORD`、`GEOIP`）。"

#: src/chimera_client/rules.md
msgid "Final fallback (`MATCH`)."
msgstr "最终兜底（`MATCH`）。"

#: src/chimera_client/rules.md
msgid "Minimal Mixed Example"
msgstr "最小混合示例"

#: src/chimera_client/rules.md
msgid "DOMAIN,internal.example.com,DIRECT"
msgstr ""

#: src/chimera_client/rules.md
msgid "DOMAIN-SUFFIX,corp.example.com,DIRECT"
msgstr ""

#: src/chimera_client/rules.md
msgid "GEOSITE,category-ads-all,REJECT"
msgstr ""

#: src/chimera_client/rules.md
msgid "MATCH,Auto"
msgstr ""

#: src/chimera_client/rules.md
msgid "Operational Tips"
msgstr "运维建议"

#: src/chimera_client/rules.md
msgid ""
"Keep rule intent explicit; avoid overlapping broad rules early in the list."
msgstr "保持规则意图清晰；避免在列表前部放置相互重叠的宽泛规则。"

#: src/chimera_client/rules.md
msgid "Validate GeoIP/GeoSite databases and provider freshness regularly."
msgstr "定期校验 GeoIP/GeoSite 数据库与规则提供器的更新时效。"

#: src/chimera_client/rules.md
msgid ""
"For debugging, enable connection logs and verify which rule each flow hits."
msgstr "调试时请开启连接日志，并确认每条流量实际命中的规则。"

#: src/chimera_client/rules.md
msgid ""
"In transparent proxy mode, ensure DNS strategy and rule logic are aligned to"
" avoid mismatches."
msgstr "在透明代理模式下，确保 DNS 策略与规则逻辑一致，避免错配。"

#: src/chimera.md
msgid "Mission and Capabilities"
msgstr "使命与能力"

#: src/chimera.md
msgid ""
"`Chimera` serves as the high-performance ingress tier that terminates client"
" sessions, enforces policies, and bridges traffic to target destinations. It"
" is optimized for multi-tenant deployments where each ingress port may "
"advertise multiple proxy protocols simultaneously. Chimera emphasizes: "
"minimal handshake latency, fine-grained access control, horizontal "
"scalability, and integrated observability."
msgstr ""
"`Chimera` "
"作为高性能入口层，负责终止客户端会话、执行策略，并将流量桥接到目标目的地。它针对多租户部署优化，每个入口端口可同时提供多种代理协议。Chimera "
"强调：最小化握手延迟、细粒度访问控制、水平扩展能力以及一体化可观测性。"

#: src/chimera.md
msgid "Component Breakdown"
msgstr "组件构成"

#: src/chimera.md
msgid ""
"The server is organized into listener frontends, authentication middleware, "
"routing fabric, and egress adaptors. Listener frontends accept TCP, TLS, "
"QUIC, or WebSocket connections and delegate deciphering to protocol handlers"
" derived from `chimera_core`. Authentication middleware layers include "
"static tokens, mTLS, external OIDC checks, and short-lived capability "
"tickets. The routing fabric maps authenticated sessions to upstream "
"clusters, optionally applying geo-aware or latency-aware load balancing. "
"Egress adaptors speak raw TCP/UDP, HTTP/2, or custom backhaul protocols. "
"Pluggable filters allow L7 inspection, rate limiting, and protocol "
"translation."
msgstr ""
"服务器由监听前端、认证中间件、路由骨干以及出口适配器组成。监听前端接受 TCP、TLS、QUIC 或 WebSocket 连接，并将解码工作交给源自 "
"`chimera_core` 的协议处理器。认证中间件层包括静态令牌、mTLS、外部 OIDC "
"校验以及短期能力票据。路由骨干将通过认证的会话映射到上游集群，并可应用地理感知或延迟感知的负载均衡。出口适配器支持原生 TCP/UDP、HTTP/2 "
"或自定义回传协议。可插拔过滤器允许进行 L7 检查、限流以及协议转换。"

#: src/chimera.md
msgid "Deployment and Scaling"
msgstr "部署与扩展"

#: src/chimera.md
msgid ""
"Chimera nodes can run bare-metal, in containers, or under orchestration "
"(Kubernetes, Nomad). A stateless design lets operators scale horizontally; "
"sticky sessions are handled through consistent hashing of client "
"identifiers. Configuration is delivered via declarative manifests that "
"describe listeners, credentials, and routing tables, with hot-reload "
"support. The project documents blueprints for single-region clusters, "
"active-active multi-region, and edge POP deployments, including how to "
"terminate QUIC at the edge while backhauling over TCP."
msgstr ""
"Chimera "
"节点可在裸机、容器或编排系统（Kubernetes、Nomad）中运行。无状态设计使运维可以水平扩展；通过对客户端标识做一致性哈希来处理会话粘性。配置通过声明式清单下发，描述监听器、凭据和路由表，并支持热更新。项目文档提供单地域集群、双活多地域以及边缘"
" POP 部署蓝图，包括如何在边缘终止 QUIC 并通过 TCP 回传。"

#: src/chimera.md
msgid "Security and Compliance"
msgstr "安全与合规"

#: src/chimera.md
msgid ""
"Security guidance covers TLS certificate management, key rotation, mixed-"
"protocol ports, and selective logging to honor privacy regulations. Built-in"
" auditing records connection metadata, rule decisions, and administrative "
"actions. Compliance appendices explain how to integrate Chimera logs with "
"SIEM platforms, enforce retention policies, and implement regulatory "
"controls such as lawful interception hooks when required."
msgstr ""
"安全指南涵盖 TLS "
"证书管理、密钥轮换、混合协议端口以及为遵守隐私法规而进行的选择性日志记录。内置审计会记录连接元数据、规则决策和管理操作。合规附录说明如何将 "
"Chimera 日志接入 SIEM 平台、执行留存策略，并在需要时实现合法截获等监管控制。"

#: src/chimera_server.md
msgid "chimera_server Library"
msgstr "chimera_server 库"

#: src/chimera_server.md
msgid "Purpose and Scope"
msgstr "用途与范围"

#: src/chimera_server.md
msgid ""
"`chimera_server` is the shared Rust crate that provides protocol primitives,"
" configuration schemas, crypto suites, and common utilities for both client "
"and server projects. By centralizing these capabilities, the ecosystem "
"avoids duplicated logic, ensures protocol compliance, and keeps security "
"fixes consistent across binaries."
msgstr ""
"`chimera_server` 是共享的 Rust "
"crate，为客户端和服务端项目提供协议原语、配置模式、密码套件以及通用工具。通过集中这些能力，生态系统避免重复逻辑，确保协议合规，并让安全修复在各二进制中保持一致。"

#: src/chimera_server.md
msgid "Key Modules"
msgstr "关键模块"

#: src/chimera_server.md
msgid ""
"Configuration model: strongly typed structures plus serde-based "
"serialization for Clash manifests, Chimera manifests, and shared policy "
"fragments."
msgstr "配置模型：用于 Clash 清单、Chimera 清单以及共享策略片段的强类型结构与基于 serde 的序列化。"

#: src/chimera_server.md
msgid ""
"Crypto and handshake utilities: AEAD ciphers, key derivation, certificate "
"pinning helpers, TLS fingerprint templates, and QUIC transport parameters."
msgstr "加密与握手工具：AEAD 加密算法、密钥派生、证书固定辅助、TLS 指纹模板以及 QUIC 传输参数。"

#: src/chimera_server.md
msgid ""
"Transport abstractions: traits for stream/session lifecycles, multiplexing "
"interfaces, buffer management, and async runtime adapters."
msgstr "传输抽象：用于流/会话生命周期的 trait 接口、多路复用接口、缓冲区管理以及异步运行时适配器。"

#: src/chimera_server.md
msgid ""
"Event bus: lightweight publish/subscribe mechanism so higher layers can tap "
"into connection lifecycle events, metrics, and alerts."
msgstr "事件总线：轻量的发布/订阅机制，使上层能够接入连接生命周期事件、指标和告警。"

#: src/chimera_server.md
msgid "API Surface and Extensibility"
msgstr "API 接口与可扩展性"

#: src/chimera_server.md
msgid ""
"The crate exposes a stable Rust API along with optional C FFI bindings for "
"other languages. Extension points allow third parties to register custom "
"cipher suites, add routing annotations, or hook into telemetry emission. "
"Versioning follows semver with clear migration guides whenever breaking "
"changes occur, ensuring that `clash-rs` and `Chimera` can track upgrades "
"smoothly."
msgstr ""
"该 crate 提供稳定的 Rust API，并可选提供 C FFI "
"绑定以供其他语言使用。扩展点允许第三方注册自定义密码套件、添加路由注解或挂接遥测输出。版本管理遵循 "
"semver，发生破坏性变更时提供清晰的迁移指南，确保 `clash-rs` 和 `Chimera` 能平滑跟进升级。"

#: src/chimera_server.md
msgid "Testing and Quality"
msgstr "测试与质量"

#: src/chimera_server.md
msgid ""
"`chimera_server` maintains exhaustive unit tests for parsers, crypto "
"primitives, and transport behaviors. Integration suites spin up in-memory "
"client/server pairs to validate interoperability before changes land. "
"Benchmarks measure handshake latency, throughput, and memory footprint "
"across representative hardware, providing baselines for regression "
"detection."
msgstr ""
"`chimera_server` "
"维护覆盖解析器、密码原语和传输行为的详尽单元测试。集成测试会启动内存中的客户端/服务端对以验证互操作性。基准测试在代表性硬件上测量握手延迟、吞吐量和内存占用，为回归检测提供基线。"

#: src/protocol.md
msgid "Default Transport"
msgstr "默认传输"

#: src/protocol.md
msgid "Authentication"
msgstr "认证"

#: src/protocol.md src/protocols/socks5.md src/protocols/http.md
#: src/protocols/trojan.md src/protocols/tuic.md src/protocols/vless.md
#: src/protocols/reality.md
msgid "Strengths"
msgstr "优势"

#: src/protocol.md
msgid "Typical Constraints"
msgstr "典型限制"

#: src/protocol.md
msgid "TCP control + optional UDP"
msgstr "TCP 控制 + 可选 UDP"

#: src/protocol.md
msgid "Optional username/password"
msgstr "可选用户名/密码"

#: src/protocol.md
msgid "Works with almost any TCP app, UDP associate mode"
msgstr "几乎兼容任何 TCP 应用，支持 UDP ASSOCIATE 模式"

#: src/protocol.md
msgid "Clear-text by default, needs TLS/obfs elsewhere"
msgstr "默认明文，需要在其他层使用 TLS/混淆"

#: src/protocol.md
msgid "HTTP(S) CONNECT"
msgstr "HTTP(S) CONNECT"

#: src/protocol.md
msgid "TCP over HTTP/1.1 or HTTP/2"
msgstr "通过 HTTP/1.1 或 HTTP/2 承载 TCP"

#: src/protocol.md
msgid "Basic auth, bearer token, mutual TLS"
msgstr "Basic 认证、Bearer 令牌、双向 TLS"

#: src/protocol.md
msgid "Blends with web traffic, easy to deploy on gateways"
msgstr "与 Web 流量融合，易于在网关部署"

#: src/protocol.md
msgid "Only proxies TCP, relies on intermediary keeping long-lived tunnels"
msgstr "仅代理 TCP，依赖中间层保持长时隧道"

#: src/protocol.md
msgid "TLS over TCP"
msgstr "基于 TCP 的 TLS"

#: src/protocol.md
msgid "Pre-shared password validated inside TLS"
msgstr "TLS 内校验预共享密码"

#: src/protocol.md
msgid "Hard to fingerprint, benefits from CDN/SNI"
msgstr "难以被指纹识别，受益于 CDN/SNI"

#: src/protocol.md
msgid "Each password maps to a port/user, needs valid TLS certificate"
msgstr "每个密码映射到端口/用户，需要有效的 TLS 证书"

#: src/protocol.md
msgid "QUIC (UDP) with TLS 1.3"
msgstr "带 TLS 1.3 的 QUIC（UDP）"

#: src/protocol.md
msgid "Password or OIDC-like token"
msgstr "密码或类似 OIDC 的令牌"

#: src/protocol.md
msgid "High throughput, UDP native, congestion tuning"
msgstr "高吞吐、原生 UDP、支持拥塞调优"

#: src/protocol.md
msgid "Requires open UDP ports, MTU tuning important"
msgstr "需要开放 UDP 端口，MTU 调优很重要"

#: src/protocol.md
msgid "UUID or token-based auth"
msgstr ""

#: src/protocol.md
msgid "0-RTT friendly, multiplexed streams, low handshake overhead"
msgstr ""

#: src/protocol.md
msgid "Needs UDP reachability, QUIC fingerprinting varies by implementation"
msgstr ""

#: src/protocol.md
msgid "TLS/XTLS over TCP or MKCP"
msgstr "基于 TCP 或 MKCP 的 TLS/XTLS"

#: src/protocol.md
msgid "UUID-based identity"
msgstr "基于 UUID 的身份"

#: src/protocol.md
msgid "Flexible multiplexing, optional XTLS auto-split"
msgstr "灵活的多路复用，可选 XTLS 自动拆分"

#: src/protocol.md
msgid "No encryption without TLS/XTLS layer, ecosystem-specific tooling"
msgstr "缺少 TLS/XTLS 层则无加密，工具生态较为特定"

#: src/protocol.md
msgid "HTTP-style stream over TLS/Reality"
msgstr "基于 TLS/Reality 的类 HTTP 流"

#: src/protocol.md
msgid "Usually UUID/token from upper protocol (e.g., VLESS)"
msgstr "通常使用上层协议（如 VLESS）的 UUID/Token"

#: src/protocol.md
msgid "Better web-traffic camouflage, friendly to reverse proxies/CDNs"
msgstr "更好的 Web 流量伪装，且对反向代理/CDN 友好"

#: src/protocol.md
msgid "Header/path mismatch breaks handshake; extra overhead versus raw TCP"
msgstr "请求头/路径不一致会导致握手失败；相较裸 TCP 有额外开销"

#: src/protocol.md
msgid "Reality (TLS camouflage)"
msgstr ""

#: src/protocol.md
#, fuzzy
msgid "TLS 1.3-like handshake"
msgstr "TLS 握手"

#: src/protocol.md
msgid "Public key + short ID (plus upstream auth)"
msgstr ""

#: src/protocol.md
msgid "Certificate-less TLS mimicry, resistant to passive probing"
msgstr ""

#: src/protocol.md
msgid "Depends on client fingerprint matching, tied to Xray tooling"
msgstr ""

#: src/protocol.md
msgid ""
"Detailed breakdowns now live in dedicated files; each follows the same "
"structure (highlights, flow, configuration snippet, strengths, and "
"limitations) to make comparisons straightforward."
msgstr "详细拆解已移至独立文件；每个文件都遵循相同结构（亮点、流程、配置片段、优势与限制），便于对比。"

#: src/protocol.md
msgid "Deep Dives"
msgstr "深入解析"

#: src/protocol.md
msgid ""
"[SOCKS5](./protocols/socks5.md) – General-purpose TCP/UDP proxy with "
"flexible method negotiation."
msgstr "[SOCKS5](./protocols/socks5.md) – 通用的 TCP/UDP 代理，支持灵活的方法协商。"

#: src/protocol.md
msgid ""
"[HTTP CONNECT Proxy](./protocols/http.md) – HTTPS-friendly tunnels that ride"
" over standard web ports."
msgstr "[HTTP CONNECT Proxy](./protocols/http.md) – 基于标准 Web 端口的 HTTPS 友好隧道。"

#: src/protocol.md
msgid ""
"[Trojan](./protocols/trojan.md) – TLS-camouflaged password proxy ideal for "
"CDN fronting."
msgstr "[Trojan](./protocols/trojan.md) – 以 TLS 伪装的密码代理，适合 CDN 前置。"

#: src/protocol.md
msgid ""
"[Hysteria 2](./protocols/hysteria2.md) – QUIC-based transport tuned for "
"high-loss or high-latency links."
msgstr "[Hysteria 2](./protocols/hysteria2.md) – 基于 QUIC 的传输，针对高丢包或高延迟链路优化。"

#: src/protocol.md
msgid ""
"[TUIC](./protocols/tuic.md) – QUIC-based proxy with multiplexing and "
"aggressive latency tuning."
msgstr ""

#: src/protocol.md
msgid ""
"[VLESS](./protocols/vless.md) – UUID-auth protocol with configurable "
"transports such as TLS, XTLS, or Reality."
msgstr ""
"[VLESS](./protocols/vless.md) – 基于 UUID 认证的协议，传输层可配置 TLS、XTLS 或 Reality。"

#: src/protocol.md
msgid ""
"[xHTTP Transport](./protocols/xhttp.md) – HTTP-like transport profile for "
"Xray ecosystems, often paired with VLESS."
msgstr ""
"[xHTTP 传输](./protocols/xhttp.md)——面向 Xray 生态的类 HTTP 传输形态，常与 VLESS 搭配使用。"

#: src/protocol.md
msgid ""
"[Reality](./protocols/reality.md) – TLS camouflage layer used by Xray "
"transports without certificates."
msgstr ""

#: src/protocols/socks5.md
msgid "Official RFC"
msgstr "官方 RFC"

#: src/protocols/socks5.md
msgid ""
"The SOCKS version 5 protocol is specified primarily in **[RFC "
"1928](https://www.rfc-editor.org/rfc/rfc1928)**."
msgstr ""
"SOCKS 第 5 版协议主要由 **[RFC 1928](https://www.rfc-editor.org/rfc/rfc1928)** 规定。"

#: src/protocols/socks5.md
msgid "**Key related RFCs:**"
msgstr "**关键 RFC：**"

#: src/protocols/socks5.md
msgid ""
"**[RFC 1928 — SOCKS Protocol Version 5](https://www.rfc-"
"editor.org/rfc/rfc1928)** (core protocol, addressing, UDP ASSOCIATE, "
"authentication negotiation)"
msgstr ""
"**[RFC 1928 — SOCKS Protocol Version 5](https://www.rfc-"
"editor.org/rfc/rfc1928)**（核心协议、寻址、UDP ASSOCIATE、认证协商）"

#: src/protocols/socks5.md
msgid ""
"**[RFC 1929 — Username/Password Authentication for SOCKS "
"V5](https://www.rfc-editor.org/rfc/rfc1929)** (optional authentication "
"method)"
msgstr ""
"**[RFC 1929 — Username/Password Authentication for SOCKS "
"V5](https://www.rfc-editor.org/rfc/rfc1929)**（可选的用户名/密码认证方法）"

#: src/protocols/socks5.md
msgid ""
"**[RFC 1961 — GSS-API Authentication Method for SOCKS V5](https://www.rfc-"
"editor.org/rfc/rfc1961)** (optional authentication)"
msgstr ""
"**[RFC 1961 — GSS-API Authentication Method for SOCKS V5](https://www.rfc-"
"editor.org/rfc/rfc1961)**（可选认证）"

#: src/protocols/socks5.md
msgid ""
"**[RFC 3089 — SOCKS-based IPv6/IPv4 Gateway](https://www.rfc-"
"editor.org/rfc/rfc3089)** (interoperability for IPv6 scenarios)"
msgstr ""
"**[RFC 3089 — SOCKS-based IPv6/IPv4 Gateway](https://www.rfc-"
"editor.org/rfc/rfc3089)**（IPv6 场景下的互操作性）"

#: src/protocols/socks5.md src/protocols/http.md src/protocols/trojan.md
#: src/protocols/tuic.md src/protocols/vless.md src/protocols/reality.md
msgid "Highlights"
msgstr "亮点"

#: src/protocols/socks5.md
msgid ""
"Layer-4 proxy that forwards arbitrary TCP streams and supports UDP via "
"ASSOCIATE command."
msgstr "四层代理，可转发任意 TCP 流，并通过 ASSOCIATE 命令支持 UDP。"

#: src/protocols/socks5.md
msgid ""
"Method negotiation lets the server advertise `NO AUTH`, `USERPASS`, or "
"custom authentication."
msgstr "方法协商允许服务器声明 `NO AUTH`、`USERPASS` 或自定义认证。"

#: src/protocols/socks5.md
msgid "Widely supported by browsers, curl, SSH, and VPN clients."
msgstr "被浏览器、curl、SSH 和 VPN 客户端广泛支持。"

#: src/protocols/socks5.md src/protocols/http.md src/protocols/trojan.md
#: src/protocols/tuic.md src/protocols/vless.md src/protocols/reality.md
msgid "Flow"
msgstr "流程"

#: src/protocols/socks5.md
msgid "Client opens a TCP socket to the proxy."
msgstr "客户端向代理打开一个 TCP 套接字。"

#: src/protocols/socks5.md
msgid ""
"Client sends a list of supported authentication methods; server responds "
"with the chosen method."
msgstr "客户端发送支持的认证方法列表；服务器返回选定的方法。"

#: src/protocols/socks5.md
msgid "Optional username/password exchange takes place."
msgstr "可选的用户名/密码交换。"

#: src/protocols/socks5.md
msgid ""
"Client issues `CONNECT`, `BIND`, or `UDP ASSOCIATE` with destination info."
msgstr "客户端携带目标信息发送 `CONNECT`、`BIND` 或 `UDP ASSOCIATE`。"

#: src/protocols/socks5.md
msgid "Server replies with success/failure code and starts relaying traffic."
msgstr "服务器返回成功/失败码并开始转发流量。"

#: src/protocols/socks5.md src/protocols/http.md src/protocols/tuic.md
#: src/protocols/vless.md src/protocols/reality.md
msgid "Configuration Snippet"
msgstr "配置片段"

#: src/protocols/socks5.md
msgid "Works with legacy tooling without extra plugins."
msgstr "无需额外插件即可配合传统工具使用。"

#: src/protocols/socks5.md
msgid "UDP associate makes DNS-over-UDP possible."
msgstr "UDP ASSOCIATE 使 DNS-over-UDP 成为可能。"

#: src/protocols/socks5.md
msgid "Minimal framing overhead keeps latency low."
msgstr "最小的封装开销保持低延迟。"

#: src/protocols/socks5.md src/protocols/http.md src/protocols/trojan.md
#: src/protocols/tuic.md src/protocols/vless.md src/protocols/reality.md
msgid "Limitations"
msgstr "限制"

#: src/protocols/socks5.md
msgid ""
"No built-in encryption; must rely on TLS-over-SOCKS or upstream obfuscation."
msgstr "没有内置加密；必须依赖 TLS-over-SOCKS 或上游混淆。"

#: src/protocols/socks5.md
msgid ""
"UDP associate requires the client to keep listening on a local port, which "
"some firewalls block."
msgstr "UDP ASSOCIATE 要求客户端持续监听本地端口，部分防火墙会阻断。"

#: src/protocols/socks5.md
msgid "Authentication is static unless wrapped in a management layer."
msgstr "认证通常是静态的，除非再加一层管理机制。"

#: src/protocols/socks5.md src/protocols/trojan.md
#: src/protocols/trojan/traffic-handling.md src/protocols/hysteria2.md
msgid "References"
msgstr "参考资料"

#: src/protocols/socks5.md
msgid "https://www.rfc-editor.org/rfc/rfc1928"
msgstr "https://www.rfc-editor.org/rfc/rfc1928"

#: src/protocols/socks5.md
msgid "https://www.rfc-editor.org/rfc/rfc1929"
msgstr "https://www.rfc-editor.org/rfc/rfc1929"

#: src/protocols/socks5.md
msgid "https://www.rfc-editor.org/rfc/rfc1961"
msgstr "https://www.rfc-editor.org/rfc/rfc1961"

#: src/protocols/socks5.md
msgid "https://www.rfc-editor.org/rfc/rfc3089"
msgstr "https://www.rfc-editor.org/rfc/rfc3089"

#: src/protocols/socks5.md
msgid "Appendices"
msgstr "附录"

#: src/protocols/socks5.md
msgid "RFC 1928 (Full Text)"
msgstr "RFC 1928（全文）"

#: src/protocols/http.md
msgid ""
"Presents itself as a normal HTTP(S) server and upgrades individual requests "
"into tunnels via the `CONNECT` verb."
msgstr "表现为普通的 HTTP(S) 服务器，通过 `CONNECT` 方法将单个请求升级为隧道。"

#: src/protocols/http.md
msgid "Easy to front with Nginx, Apache, or cloud load balancers."
msgstr "易于使用 Nginx、Apache 或云负载均衡进行前置。"

#: src/protocols/http.md
msgid "Supports HTTP/2 multiplexing when both sides understand it."
msgstr "双方支持时可使用 HTTP/2 多路复用。"

#: src/protocols/http.md
msgid "Client opens a TCP (or TLS) connection to the proxy endpoint."
msgstr "客户端与代理端点建立 TCP（或 TLS）连接。"

#: src/protocols/http.md
msgid ""
"Client optionally performs HTTP auth (Basic, Digest, Bearer, or mutual TLS)."
msgstr "客户端可选进行 HTTP 认证（Basic、Digest、Bearer 或双向 TLS）。"

#: src/protocols/http.md
msgid ""
"Client sends `CONNECT target.example.com:443 HTTP/1.1` (or an HTTP/2 "
"`:method CONNECT`)."
msgstr ""
"客户端发送 `CONNECT target.example.com:443 HTTP/1.1`（或 HTTP/2 的 `:method "
"CONNECT`）。"

#: src/protocols/http.md
msgid "Proxy validates policy, then responds `200 Connection Established`."
msgstr "代理校验策略后返回 `200 Connection Established`。"

#: src/protocols/http.md
msgid ""
"Subsequent bytes are relayed transparently until one side closes the tunnel."
msgstr "后续字节透明转发，直到任一侧关闭隧道。"

#: src/protocols/http.md
msgid ""
"Blends with standard HTTPS traffic; hard to distinguish from regular web "
"browsing."
msgstr "与标准 HTTPS 流量混在一起，难以与普通网页浏览区分。"

#: src/protocols/http.md
msgid "Works well behind corporate firewalls that only permit ports 80/443."
msgstr "适合在只允许 80/443 端口的企业防火墙后使用。"

#: src/protocols/http.md
msgid ""
"HTTP/2 variants allow many tunnels over one TCP session, reducing handshake "
"cost."
msgstr "HTTP/2 变体可在单个 TCP 会话上复用多条隧道，降低握手成本。"

#: src/protocols/http.md
msgid "TCP-only; cannot forward UDP flows without extra encapsulation."
msgstr "仅支持 TCP；不经额外封装无法转发 UDP 流。"

#: src/protocols/http.md
msgid ""
"Proxies must maintain state per tunnel, which impacts scaling under many "
"short-lived connections."
msgstr "代理需为每条隧道维护状态，在大量短连接下会影响扩展性。"

#: src/protocols/http.md
msgid "Additional HTTP headers may leak metadata if not sanitized."
msgstr "若未清理，额外的 HTTP 头可能泄露元数据。"

#: src/protocols/trojan.md
msgid ""
"Starts with a real TLS handshake; all subsequent bytes are TLS application "
"data."
msgstr "以真实的 TLS 握手开始；后续所有字节都是 TLS 应用数据。"

#: src/protocols/trojan.md
msgid "Auth is a pre-shared password hashed with SHA-224 and hex encoded."
msgstr "认证方式是对预共享密码进行 SHA-224 哈希并做十六进制编码。"

#: src/protocols/trojan.md
msgid ""
"Request framing reuses SOCKS5-style address fields for CONNECT and UDP "
"ASSOCIATE."
msgstr "请求帧复用 SOCKS5 风格的地址字段，用于 CONNECT 和 UDP ASSOCIATE。"

#: src/protocols/trojan.md
msgid ""
"Invalid or unknown traffic can be forwarded to a fallback endpoint to look "
"like normal HTTPS."
msgstr "无效或未知流量可以转发到回落端点，使其看起来像正常的 HTTPS。"

#: src/protocols/trojan.md
msgid ""
"Client completes a standard TLS handshake with the server (SNI/ALPN as "
"configured)."
msgstr "客户端与服务器完成标准 TLS 握手（SNI/ALPN 按配置）。"

#: src/protocols/trojan.md
msgid ""
"Client sends `hex(SHA224(password))` + CRLF + Trojan Request + CRLF (+ "
"optional payload)."
msgstr "客户端发送 `hex(SHA224(password))` + CRLF + Trojan Request + CRLF（+ 可选负载）。"

#: src/protocols/trojan.md
msgid ""
"Server validates the password and request, then connects to the destination."
msgstr "服务器校验密码与请求，然后连接到目标。"

#: src/protocols/trojan.md
msgid ""
"For TCP, data is relayed bidirectionally; for UDP, packets are framed and "
"tunneled over the TLS stream."
msgstr "对 TCP，数据双向转发；对 UDP，数据包会被封装并通过 TLS 流隧道传输。"

#: src/protocols/trojan.md
msgid ""
"The precise framing and field definitions live in [Wire "
"Format](./trojan/wire-format.md)."
msgstr "精确的帧格式与字段定义见 [报文格式](./trojan/wire-format.md)。"

#: src/protocols/trojan.md
msgid ""
"The first TLS record may include payload after the request to reduce packet "
"count."
msgstr "首个 TLS 记录可在请求之后携带负载，以减少数据包数量。"

#: src/protocols/trojan.md
msgid ""
"Fallback behavior and anti-detection notes are in [Traffic "
"Handling](./trojan/traffic-handling.md)."
msgstr "回落行为与反探测说明见 [流量处理](./trojan/traffic-handling.md)。"

#: src/protocols/trojan.md
msgid ""
"Uses standard TLS stacks and certificates; inherits mature TLS security and "
"ALPN support."
msgstr "使用标准 TLS 栈和证书，继承成熟的 TLS 安全性与 ALPN 支持。"

#: src/protocols/trojan.md
msgid "Hard to fingerprint when served from a legitimate HTTPS endpoint."
msgstr "当由合法的 HTTPS 端点提供服务时，难以进行指纹识别。"

#: src/protocols/trojan.md
msgid "Minimal protocol overhead once the handshake completes."
msgstr "握手完成后，协议开销很小。"

#: src/protocols/trojan.md
msgid ""
"Shared-password model means revocation is coarse unless per-user passwords "
"are used."
msgstr "共享密码模式意味着撤销粒度较粗，除非使用按用户分配的密码。"

#: src/protocols/trojan.md
msgid "Requires valid TLS certificates and operational renewal."
msgstr "需要有效的 TLS 证书并进行运维续期。"

#: src/protocols/trojan.md
msgid ""
"Fallback behavior must be configured to keep probes indistinguishable from "
"real HTTPS."
msgstr "必须配置回落行为，使探测与真实 HTTPS 无法区分。"

#: src/protocols/trojan.md
msgid "https://trojan-gfw.github.io/trojan/protocol"
msgstr "https://trojan-gfw.github.io/trojan/protocol"

#: src/protocols/trojan/wire-format.md
msgid "Trojan Wire Format"
msgstr "Trojan 报文格式"

#: src/protocols/trojan/wire-format.md
msgid "TLS Handshake"
msgstr "TLS 握手"

#: src/protocols/trojan/wire-format.md
msgid "The client performs a normal TLS handshake first."
msgstr "客户端首先执行一次标准的 TLS 握手。"

#: src/protocols/trojan/wire-format.md
msgid ""
"If the handshake fails, the server closes the connection like a regular "
"HTTPS server."
msgstr "如果握手失败，服务器会像普通 HTTPS 服务器一样关闭连接。"

#: src/protocols/trojan/wire-format.md
msgid ""
"Some implementations also return an nginx-like response to plain HTTP "
"probes."
msgstr "一些实现还会对纯 HTTP 探测返回类似 nginx 的响应。"

#: src/protocols/trojan/wire-format.md
msgid "Initial Request"
msgstr "初始请求"

#: src/protocols/trojan/wire-format.md
msgid "After TLS is established, the first application data packet is:"
msgstr "TLS 建立后，首个应用数据包为："

#: src/protocols/trojan/wire-format.md
msgid "Trojan Request"
msgstr "Trojan Request"

#: src/protocols/trojan/wire-format.md
msgid "Trojan Request uses a SOCKS5-like format:"
msgstr "Trojan Request 使用类 SOCKS5 格式："

#: src/protocols/trojan/wire-format.md
msgid "CMD values: 0x01 CONNECT, 0x03 UDP ASSOCIATE."
msgstr "CMD 值：0x01 CONNECT，0x03 UDP ASSOCIATE。"

#: src/protocols/trojan/wire-format.md
msgid "ATYP values: 0x01 IPv4, 0x03 DOMAINNAME, 0x04 IPv6."
msgstr "ATYP 值：0x01 IPv4，0x03 DOMAINNAME，0x04 IPv6。"

#: src/protocols/trojan/wire-format.md
msgid "DST.ADDR is the destination address, DST.PORT is network byte order."
msgstr "DST.ADDR 为目标地址，DST.PORT 使用网络字节序。"

#: src/protocols/trojan/wire-format.md
msgid "SOCKS5 field details: https://tools.ietf.org/html/rfc1928"
msgstr "SOCKS5 字段细节：https://tools.ietf.org/html/rfc1928"

#: src/protocols/trojan/wire-format.md
msgid "UDP Associate Framing"
msgstr "UDP ASSOCIATE 帧格式"

#: src/protocols/trojan/wire-format.md
msgid ""
"When CMD is UDP ASSOCIATE, each UDP datagram is framed in the TLS stream as:"
msgstr "当 CMD 为 UDP ASSOCIATE 时，每个 UDP 数据报在 TLS 流中的帧格式为："

#: src/protocols/trojan/wire-format.md
msgid "Length is the payload size in network byte order."
msgstr "Length 为负载大小，使用网络字节序。"

#: src/protocols/trojan/wire-format.md
msgid "Payload is the raw UDP datagram."
msgstr "Payload 为原始 UDP 数据报。"

#: src/protocols/trojan/wire-format.md
msgid ""
"The first TLS record can include payload immediately after the request, "
"reducing packet count and length patterns."
msgstr "首个 TLS 记录可在请求后立即携带负载，从而减少数据包数量与长度模式。"

#: src/protocols/trojan/wire-format.md
msgid ""
"Clients often expose a local SOCKS5 proxy and translate local SOCKS5 "
"requests into Trojan requests."
msgstr "客户端通常会提供本地 SOCKS5 代理，并将本地 SOCKS5 请求转换为 Trojan 请求。"

#: src/protocols/trojan/traffic-handling.md
msgid "Trojan Traffic Handling"
msgstr "Trojan 流量处理"

#: src/protocols/trojan/traffic-handling.md
msgid "Other Protocols (Fallback)"
msgstr "其他协议（回落）"

#: src/protocols/trojan/traffic-handling.md
msgid "Trojan listens on a TLS socket like a normal HTTPS service."
msgstr "Trojan 像普通 HTTPS 服务一样监听 TLS 套接字。"

#: src/protocols/trojan/traffic-handling.md
msgid ""
"After TLS completes, the server inspects the first application data packet."
msgstr "TLS 完成后，服务器检查第一个应用数据包。"

#: src/protocols/trojan/traffic-handling.md
msgid ""
"If the packet is not a valid Trojan request (wrong structure or password), "
"the server treats it as \"other protocols\" and forwards the decrypted TLS "
"stream to a preset endpoint (default `127.0.0.1:80`)."
msgstr ""
"如果该数据包不是有效的 Trojan 请求（结构或密码错误），服务器会将其视为“其他协议”，并把解密后的 TLS 流转发到预设端点（默认 "
"`127.0.0.1:80`）。"

#: src/protocols/trojan/traffic-handling.md
msgid ""
"The preset endpoint then controls the response, keeping the behavior "
"indistinguishable from a real HTTPS site."
msgstr "预设端点随后控制响应，使其行为与真实 HTTPS 站点无异。"

#: src/protocols/trojan/traffic-handling.md
msgid "Active Detection"
msgstr "主动检测"

#: src/protocols/trojan/traffic-handling.md
msgid ""
"Probes without the correct structure or password are handed to the fallback "
"endpoint."
msgstr "结构或密码不正确的探测会被交给回落端点。"

#: src/protocols/trojan/traffic-handling.md
msgid ""
"As a result, active scanners see ordinary HTTPS or HTTP behavior rather than"
" a bespoke proxy banner."
msgstr "因此，主动扫描器看到的是普通 HTTPS 或 HTTP 行为，而非定制的代理标识。"

#: src/protocols/trojan/traffic-handling.md
msgid "Passive Detection"
msgstr "被动检测"

#: src/protocols/trojan/traffic-handling.md
msgid ""
"With a valid certificate, traffic is protected by TLS and resembles ordinary"
" HTTPS."
msgstr "使用有效证书时，流量受 TLS 保护，看起来像普通 HTTPS。"

#: src/protocols/trojan/traffic-handling.md
msgid ""
"For HTTP destinations, there is only one RTT after the TLS handshake; non-"
"HTTP traffic often looks like HTTPS keepalive or WebSocket."
msgstr "对于 HTTP 目的地，TLS 握手后只有一个 RTT；非 HTTP 流量常表现为 HTTPS 保活或WebSocket。"

#: src/protocols/trojan/traffic-handling.md
msgid ""
"This similarity can help bypass ISP QoS that targets obvious proxy "
"signatures."
msgstr "这种相似性有助于绕过针对明显代理特征的 ISP QoS。"

#: src/protocols/trojan/traffic-handling.md
msgid "https://github.com/trojan-gfw/trojan/issues/14"
msgstr "https://github.com/trojan-gfw/trojan/issues/14"

#: src/protocols/hysteria2.md
msgid "https://v2.hysteria.network/zh/docs/developers/Protocol/"
msgstr "https://v2.hysteria.network/zh/docs/developers/Protocol/"

#: src/protocols/hysteria2.md
msgid "Hysteria 2 Protocol Specification"
msgstr "Hysteria 2 协议规范"

#: src/protocols/hysteria2.md
msgid ""
"Hysteria is a TCP & UDP proxy based on QUIC, designed for speed, security "
"and censorship resistance. This document describes the protocol used by "
"Hysteria starting with version 2.0.0, sometimes internally referred to as "
"the \"v4\" protocol. From here on, we will call it \"the protocol\" or \"the"
" Hysteria protocol\"."
msgstr ""
"Hysteria 是基于 QUIC 的 TCP 与 UDP 代理，旨在提供速度、安全性与抗审查能力。本文档描述 Hysteria 自 2.0.0 "
"版本起使用的协议，内部有时称为\"v4\"协议。下文将其称为\"该协议\"或\"Hysteria 协议\"。"

#: src/protocols/hysteria2.md
msgid "Requirements Language"
msgstr "规范性语言"

#: src/protocols/hysteria2.md
msgid ""
"The keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\","
" \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in "
"this document are to be interpreted as described in RFC 2119: "
"https://tools.ietf.org/html/rfc2119"
msgstr ""
"本文档中的关键词\"MUST\"、\"MUST NOT\"、\"REQUIRED\"、\"SHALL\"、\"SHALL "
"NOT\"、\"SHOULD\"、\"SHOULD NOT\"、\"RECOMMENDED\"、\"MAY\" 和 \"OPTIONAL\"的含义应按 "
"RFC 2119 解释：https://tools.ietf.org/html/rfc2119"

#: src/protocols/hysteria2.md
msgid "Underlying Protocol & Wire Format"
msgstr "底层协议与报文格式"

#: src/protocols/hysteria2.md
msgid ""
"The Hysteria protocol MUST be implemented on top of the standard QUIC "
"transport protocol (RFC 9000) with the Unreliable Datagram Extension (RFC "
"9221)."
msgstr "Hysteria 协议 MUST 构建在标准 QUIC 传输协议（RFC 9000）之上，并使用不可靠数据报扩展（RFC 9221）。"

#: src/protocols/hysteria2.md
msgid "All multibyte numbers use Big Endian format."
msgstr "所有多字节数字均使用大端字节序。"

#: src/protocols/hysteria2.md
msgid ""
"All variable-length integers (\"varints\") are encoded/decoded as defined in"
" QUIC (RFC 9000)."
msgstr "所有变长整数（\"varints\"）按 QUIC（RFC 9000）定义进行编码/解码。"

#: src/protocols/hysteria2.md
msgid "Authentication & HTTP/3 masquerading"
msgstr "认证与 HTTP/3 伪装"

#: src/protocols/hysteria2.md
msgid ""
"One of the key features of the Hysteria protocol is that to a third party "
"without proper authentication credentials (whether it's a middleman or an "
"active prober), a Hysteria proxy server behaves just like a standard HTTP/3 "
"web server. Additionally, the encrypted traffic between the client and the "
"server appears indistinguishable from normal HTTP/3 traffic."
msgstr ""
"Hysteria 协议的一个关键特性是：对于没有正确认证凭据的第三方（无论是中间人还是主动探测者），Hysteria 代理服务器的行为就像标准的 "
"HTTP/3 Web 服务器。此外，客户端与服务器之间的加密流量看起来与正常 HTTP/3 流量无法区分。"

#: src/protocols/hysteria2.md
msgid ""
"Therefore, a Hysteria server MUST implement an HTTP/3 server (RFC 9114) and "
"handle HTTP requests as any standard web server would. To prevent active "
"probers from detecting common response patterns in Hysteria servers, "
"implementations SHOULD advise users to either host actual content or set it "
"up as a reverse proxy for other sites."
msgstr ""
"因此，Hysteria 服务器 MUST 实现一个 HTTP/3 服务器（RFC 9114），并像标准 Web 服务器一样处理 HTTP "
"请求。为防止主动探测者发现 Hysteria 服务器的常见响应模式，实现方 SHOULD 建议用户要么托管真实内容，要么将其设置为其他站点的反向代理。"

#: src/protocols/hysteria2.md
msgid ""
"An actual Hysteria client, upon connection, MUST send the following HTTP/3 "
"request to the server:"
msgstr "真正的 Hysteria 客户端在连接后 MUST 向服务器发送以下 HTTP/3 请求："

#: src/protocols/hysteria2.md
msgid "`Hysteria-Auth`: Authentication credentials."
msgstr "`Hysteria-Auth`：认证凭据。"

#: src/protocols/hysteria2.md
msgid ""
"`Hysteria-CC-RX`: Client's maximum receive rate in bytes per second. A value"
" of 0 indicates unknown."
msgstr "`Hysteria-CC-RX`：客户端最大接收速率（字节/秒）。值为 0 表示未知。"

#: src/protocols/hysteria2.md
msgid "`Hysteria-Padding`: A random padding string of variable length."
msgstr "`Hysteria-Padding`：可变长度的随机填充字符串。"

#: src/protocols/hysteria2.md
msgid ""
"The Hysteria server MUST identify this special request, and, instead of "
"attempting to serve content or forwarding it to an upstream site, it MUST "
"authenticate the client using the provided information. If authentication is"
" successful, the server MUST send the following response (HTTP status code "
"233):"
msgstr ""
"Hysteria 服务器 MUST 识别该特殊请求，并且不会尝试提供内容或转发到上游站点，而是 MUST "
"使用所提供的信息对客户端进行认证。若认证成功，服务器 MUST 发送以下响应（HTTP 状态码 233）："

#: src/protocols/hysteria2.md
msgid ""
"```text\n"
":status: 233 HyOK\n"
"Hysteria-UDP: [true/false]\n"
"Hysteria-CC-RX: [uint/\"auto\"]\n"
"Hysteria-Padding: [string]\n"
"```"
msgstr ""
"```text\n"
":status: 233 HyOK\n"
"Hysteria-UDP: [true/false]\n"
"Hysteria-CC-RX: [uint/\"auto\"]\n"
"Hysteria-Padding: [string]\n"
"```"

#: src/protocols/hysteria2.md
msgid "`Hysteria-UDP`: Whether the server supports UDP relay."
msgstr "`Hysteria-UDP`：服务器是否支持 UDP 中继。"

#: src/protocols/hysteria2.md
msgid ""
"`Hysteria-CC-RX`: Server's maximum receive rate in bytes per second. A value"
" of 0 indicates unlimited; \"auto\" indicates the server refuses to provide "
"a value and ask the client to use congestion control to determine the rate "
"on its own."
msgstr ""
"`Hysteria-CC-RX`：服务器最大接收速率（字节/秒）。值为 0 表示无限制；\"auto\" "
"表示服务器拒绝提供该值，并要求客户端使用拥塞控制自行确定速率。"

#: src/protocols/hysteria2.md
msgid ""
"See the Congestion Control section for more information on how to use the "
"`Hysteria-CC-RX` values."
msgstr "关于如何使用 `Hysteria-CC-RX` 的取值，详见“拥塞控制”章节。"

#: src/protocols/hysteria2.md
msgid ""
"`Hysteria-Padding` is optional and is only intended to obfuscate the "
"request/response pattern. It SHOULD be ignored by both sides."
msgstr "`Hysteria-Padding` 为可选项，仅用于混淆请求/响应模式，双方 SHOULD 忽略它。"

#: src/protocols/hysteria2.md
msgid ""
"If authentication fails, the server MUST either act like a standard web "
"server that does not understand the request, or in the case of being a "
"reverse proxy, forward the request to the upstream site and return the "
"response to the client."
msgstr ""
"如果认证失败，服务器 MUST 要么表现得像不理解该请求的标准 Web 服务器，要么在其作为反向代理时，将请求转发到上游站点并将响应返回给客户端。"

#: src/protocols/hysteria2.md
msgid ""
"The client MUST check the status code to determine if the authentication was"
" successful. If the status code is anything other than 233, the client MUST "
"consider authentication to have failed and disconnect from the server."
msgstr "客户端 MUST 检查状态码以判断认证是否成功。若状态码不是 233，客户端 MUST 认为认证失败并断开与服务器的连接。"

#: src/protocols/hysteria2.md
msgid ""
"After (and only after) a client passes authentication, the server MUST "
"consider this QUIC connection to be a Hysteria proxy connection. It MUST "
"then start processing proxy requests from the client as described in the "
"next section."
msgstr ""
"客户端通过认证之后（且仅在之后），服务器 MUST 将该 QUIC 连接视为 Hysteria 代理连接，并 MUST "
"按下一节所述开始处理来自客户端的代理请求。"

#: src/protocols/hysteria2.md
msgid "Proxy Requests"
msgstr "代理请求"

#: src/protocols/hysteria2.md
msgid "TCP"
msgstr "TCP"

#: src/protocols/hysteria2.md
msgid ""
"For each TCP connection, the client MUST create a new QUIC bidirectional "
"stream and send the following TCPRequest message:"
msgstr "对于每个 TCP 连接，客户端 MUST 创建一个新的 QUIC 双向流，并发送以下 TCPRequest 消息："

#: src/protocols/hysteria2.md
msgid "The server MUST respond with a TCPResponse message:"
msgstr "服务器 MUST 以 TCPResponse 消息回应："

#: src/protocols/hysteria2.md
msgid ""
"If the status is OK, the server MUST then begin forwarding data between the "
"client and the specified TCP address until either side closes the "
"connection. If the status is Error, the server MUST close the QUIC stream."
msgstr ""
"如果状态为 OK，服务器 MUST 随后在客户端与指定的 TCP 地址之间转发数据，直到任一方关闭连接。如果状态为 Error，服务器 MUST 关闭该"
" QUIC 流。"

#: src/protocols/hysteria2.md
msgid "UDP"
msgstr "UDP"

#: src/protocols/hysteria2.md
msgid ""
"UDP packets MUST be encapsulated in the following UDPMessage format and sent"
" over QUIC's unreliable datagram (for both client-to-server and server-to-"
"client):"
msgstr ""
"UDP 数据包 MUST 按以下 UDPMessage 格式封装，并通过 QUIC 的不可靠数据报发送（客户端到服务器和服务器到客户端均如此）："

#: src/protocols/hysteria2.md
msgid ""
"The client MUST use a unique Session ID for each UDP session. The server "
"SHOULD assign a unique UDP port to each Session ID, unless it has another "
"mechanism to differentiate packets from different sessions (e.g., symmetric "
"NAT, varying outbound IP addresses, etc.)."
msgstr ""
"客户端 MUST 为每个 UDP 会话使用唯一的 Session ID。服务器 SHOULD 为每个 Session ID 分配唯一的 UDP "
"端口，除非它有其他机制区分来自不同会话的数据包（例如对称 NAT、不同的出站 IP 地址等）。"

#: src/protocols/hysteria2.md
msgid ""
"The protocol does not provide an explicit way to close a UDP session. While "
"a client can retain and reuse a Session ID indefinitely, the server SHOULD "
"release and reassign the port associated with the Session ID after a period "
"of inactivity or some other criteria. If the client sends a UDP packet to a "
"Session ID that is no longer recognized by the server, the server MUST treat"
" it as a new session and assign a new port."
msgstr ""
"该协议未提供显式关闭 UDP 会话的方法。客户端可以无限期地保留并复用 Session ID，但服务器 SHOULD "
"在一段时间不活动或基于其他条件后释放并重新分配与该 Session ID 关联的端口。如果客户端向服务器已不再识别的 Session ID 发送 UDP"
" 数据包，服务器 MUST 将其视为新会话并分配新的端口。"

#: src/protocols/hysteria2.md
msgid ""
"If a server does not support UDP relay, it SHOULD silently discard all UDP "
"messages received from the client."
msgstr "如果服务器不支持 UDP 中继，它 SHOULD 静默丢弃从客户端接收到的所有 UDP 消息。"

#: src/protocols/hysteria2.md
msgid "Fragmentation"
msgstr "分片"

#: src/protocols/hysteria2.md
msgid ""
"Due to the limit imposed by QUIC's unreliable datagram channel, any UDP "
"packet that exceeds QUIC's maximum datagram size MUST either be fragmented "
"or discarded."
msgstr "由于 QUIC 不可靠数据报通道的限制，任何超过 QUIC 最大数据报大小的 UDP 数据包 MUST 要么分片，要么被丢弃。"

#: src/protocols/hysteria2.md
msgid ""
"For fragmented packets, each fragment MUST carry the same unique Packet ID. "
"The Fragment ID, starting from 0, indicates the index out of the total "
"Fragment Count. Both the server and client MUST wait for all fragments of a "
"fragmented packet to arrive before processing them. If one or more fragments"
" of a packet are lost, the entire packet MUST be discarded."
msgstr ""
"对于分片的数据包，每个分片 MUST 携带相同的唯一 Packet ID。Fragment ID 从 0 开始，表示在总 Fragment Count "
"中的索引。服务器与客户端 MUST 等待该分片数据包的所有分片到齐后再处理；如果丢失一个或多个分片，整个数据包 MUST 被丢弃。"

#: src/protocols/hysteria2.md
msgid ""
"For packets that are not fragmented, the Fragment Count MUST be set to 1. In"
" this case, the values of Packet ID and Fragment ID are irrelevant."
msgstr ""
"对于未分片的数据包，Fragment Count MUST 设为 1。在这种情况下，Packet ID 和 Fragment ID 的值无关紧要。"

#: src/protocols/hysteria2.md
msgid "Congestion Control"
msgstr "拥塞控制"

#: src/protocols/hysteria2.md
msgid ""
"A unique feature of Hysteria is the ability to set the tx/rx "
"(upload/download) rate on the client side. During authentication, the client"
" sends its rx rate to the server via the `Hysteria-CC-RX` header. The server"
" can use this to determine its transmission rate to the client, and vice "
"versa by returning its rx rate to the client through the same header."
msgstr ""
"Hysteria 的一项独特能力是允许在客户端设置 tx/rx（上传/下载）速率。认证过程中，客户端通过 `Hysteria-CC-RX` "
"头向服务器发送其 rx 速率。服务器可据此确定向客户端的发送速率，并通过同一头返回其 rx 速率，反之亦然。"

#: src/protocols/hysteria2.md
msgid "Three special cases are:"
msgstr "有三种特殊情况："

#: src/protocols/hysteria2.md
msgid ""
"If the client sends 0, it doesn't know its own rx rate. The server MUST use "
"a congestion control algorithm (e.g., BBR, Cubic) to adjust its transmission"
" rate."
msgstr "如果客户端发送 0，表示它不知道自身的 rx 速率。服务器 MUST 使用拥塞控制算法（如 BBR、Cubic）来调整其发送速率。"

#: src/protocols/hysteria2.md
msgid ""
"If the server responds with 0, it has no bandwidth limit. The client MAY "
"transmit at any rate it wants."
msgstr "如果服务器返回 0，表示没有带宽限制。客户端 MAY 以任意速率发送。"

#: src/protocols/hysteria2.md
msgid ""
"If the server responds with \"auto\", it chooses not to specify a rate. The "
"client MUST use a congestion control algorithm to adjust its transmission "
"rate."
msgstr "如果服务器返回 \"auto\"，表示它选择不指定速率。客户端 MUST 使用拥塞控制算法来调整其发送速率。"

#: src/protocols/hysteria2.md
msgid "\"Salamander\" Obfuscation"
msgstr "\"Salamander\" 混淆"

#: src/protocols/hysteria2.md
msgid ""
"The Hysteria protocol supports an optional obfuscation layer codenamed "
"\"Salamander\"."
msgstr "Hysteria 协议支持一个可选的混淆层，代号为 \"Salamander\"。"

#: src/protocols/hysteria2.md
msgid "\"Salamander\" encapsulates all QUIC packets in the following format:"
msgstr "\"Salamander\" 将所有 QUIC 数据包封装为以下格式："

#: src/protocols/hysteria2.md
msgid ""
"For each QUIC packet, the obfuscator MUST calculate the BLAKE2b-256 hash of "
"a randomly generated 8-byte salt appended to a user-provided pre-shared key."
msgstr "对于每个 QUIC 数据包，混淆器 MUST 计算将随机生成的 8 字节盐值追加到用户提供的预共享密钥后的 BLAKE2b-256 哈希。"

#: src/protocols/hysteria2.md
msgid ""
"The hash is then used to obfuscate the payload using the following "
"algorithm:"
msgstr "随后使用该哈希按以下算法对负载进行混淆："

#: src/protocols/hysteria2.md
msgid ""
"The deobfuscator MUST use the same algorithms to calculate the salted hash "
"and deobfuscate the payload. Any invalid packet MUST be discarded."
msgstr "去混淆器 MUST 使用相同的算法计算带盐哈希并还原负载。任何无效的数据包 MUST 被丢弃。"

#: src/protocols/tuic.md
msgid ""
"QUIC-based proxy protocol that uses TLS 1.3 for encryption and stream "
"multiplexing."
msgstr ""

#: src/protocols/tuic.md
msgid "Supports 0-RTT resumption and UDP relay over QUIC datagrams."
msgstr ""

#: src/protocols/tuic.md
msgid "Designed for aggressive latency tuning with modern congestion control."
msgstr ""

#: src/protocols/tuic.md
msgid ""
"Client opens a QUIC connection to the server and completes the TLS 1.3 "
"handshake."
msgstr ""

#: src/protocols/tuic.md
msgid "Client authenticates with a UUID/token configured on the server."
msgstr ""

#: src/protocols/tuic.md
#, fuzzy
msgid ""
"Client opens bidirectional QUIC streams for TCP requests and uses datagrams "
"for UDP relay."
msgstr "认证后，客户端打开双向流用于 TCP 代理，或使用数据报处理 UDP。"

#: src/protocols/tuic.md
#, fuzzy
msgid "Server validates auth, then forwards traffic to upstream destinations."
msgstr "服务器校验 UUID 后，建立到目的地的流或数据报隧道。"

#: src/protocols/tuic.md
msgid "Low handshake overhead with 0-RTT and multiplexed streams."
msgstr ""

#: src/protocols/tuic.md
#, fuzzy
msgid "Handles UDP natively without extra encapsulation layers."
msgstr "仅支持 TCP；不经额外封装无法转发 UDP 流。"

#: src/protocols/tuic.md
msgid "Good performance on lossy or high-latency mobile networks."
msgstr ""

#: src/protocols/tuic.md
#, fuzzy
msgid "Requires UDP reachability and QUIC-friendly network paths."
msgstr "需要稳定的 UDP 可达性；一些企业网络会阻断出站 UDP。"

#: src/protocols/tuic.md
msgid ""
"QUIC fingerprints vary by implementation and can be throttled or blocked."
msgstr ""

#: src/protocols/tuic.md
msgid "MTU and packet pacing tuning are often required for best results."
msgstr ""

#: src/protocols/vless.md
msgid ""
"Lightweight stateless protocol from Project V that uses UUIDs for client "
"identification."
msgstr "来自 Project V 的轻量无状态协议，使用 UUID 作为客户端标识。"

#: src/protocols/vless.md
msgid ""
"Typically paired with TLS, XTLS, or Reality transport layers for encryption "
"and camouflage."
msgstr "通常与 TLS、XTLS 或 Reality 传输层搭配，用于加密与伪装。"

#: src/protocols/vless.md
msgid ""
"Supports multiplexing, fallback routes, and advanced routing rules within "
"the Xray core ecosystem."
msgstr "在 Xray-core 生态内支持多路复用、回退路由和高级路由规则。"

#: src/protocols/vless.md
msgid ""
"Client connects to the server transport (TLS, XTLS, Reality, gRPC, or MKCP)."
msgstr "客户端连接到服务器传输层（TLS、XTLS、Reality、gRPC 或 MKCP）。"

#: src/protocols/vless.md
msgid ""
"Client sends a VLESS header carrying the UUID, command (TCP/UDP), and target"
" address."
msgstr "客户端发送包含 UUID、命令（TCP/UDP）和目标地址的 VLESS 头。"

#: src/protocols/vless.md
msgid ""
"Server validates the UUID, then opens a stream or datagram tunnel to the "
"destination."
msgstr "服务器校验 UUID 后，建立到目的地的流或数据报隧道。"

#: src/protocols/vless.md
msgid ""
"Optional features such as Flow Control Transport (FCT) or XTLS split "
"accelerate traffic."
msgstr "可选功能如 Flow Control Transport（FCT）或 XTLS 拆分可加速流量。"

#: src/protocols/vless.md
msgid ""
"UUID-based auth scales well for many users and integrates with automated "
"issuers."
msgstr "基于 UUID 的认证易于扩展到大量用户，并可与自动化签发系统集成。"

#: src/protocols/vless.md
msgid ""
"Compatible with multiple transports, giving flexibility between TCP, gRPC, "
"WS, or QUIC layers."
msgstr "兼容多种传输层，在 TCP、gRPC、WS 或 QUIC 之间提供灵活选择。"

#: src/protocols/vless.md
msgid ""
"XTLS/Reality options reduce TLS overhead and mimic legitimate HTTPS "
"fingerprints."
msgstr "XTLS/Reality 选项降低 TLS 开销并模拟合法 HTTPS 指纹。"

#: src/protocols/vless.md
msgid ""
"Requires the Xray-core ecosystem; not natively supported by mainstream OS "
"tools."
msgstr "依赖 Xray-core 生态；主流操作系统工具并不原生支持。"

#: src/protocols/vless.md
msgid ""
"Misconfiguration of flow parameters can break compatibility with older "
"clients."
msgstr "流控参数配置错误会破坏与旧客户端的兼容性。"

#: src/protocols/vless.md
msgid ""
"Security relies heavily on the chosen transport; bare VLESS without TLS "
"offers no encryption."
msgstr "安全性高度依赖所选传输层；不带 TLS 的裸 VLESS 没有加密。"

#: src/protocols/xhttp.md
msgid ""
"xHTTP is an Xray transport that tunnels proxy traffic through regular HTTP "
"request/response patterns, making it look closer to normal web application "
"traffic. It is commonly used with VLESS + TLS/Reality to improve camouflage "
"and traverse restrictive network environments."
msgstr ""
"xHTTP 是 Xray 的一种传输方式，它通过常规 HTTP 请求/响应模式承载代理流量，使其更接近普通 Web 应用流量。它常与 VLESS + "
"TLS/Reality 搭配使用，以增强伪装并穿越受限网络环境。"

#: src/protocols/xhttp.md
msgid "When to Use"
msgstr "适用场景"

#: src/protocols/xhttp.md
msgid "You need traffic to blend into common HTTPS API patterns."
msgstr "你需要让流量融入常见 HTTPS API 访问模式。"

#: src/protocols/xhttp.md
msgid ""
"Your network environment is sensitive to long-lived WebSocket or gRPC "
"signatures."
msgstr "你的网络环境对长连接 WebSocket 或 gRPC 特征较敏感。"

#: src/protocols/xhttp.md
msgid ""
"You want to combine VLESS identity/auth with HTTP-style uplink/downlink "
"behavior."
msgstr "你希望将 VLESS 的身份认证与 HTTP 风格的上下行行为结合。"

#: src/protocols/xhttp.md
msgid "Core Configuration Fields"
msgstr "核心配置字段"

#: src/protocols/xhttp.md
msgid "Field"
msgstr "字段"

#: src/protocols/xhttp.md
msgid "Side"
msgstr "侧别"

#: src/protocols/xhttp.md
msgid "Meaning"
msgstr "含义"

#: src/protocols/xhttp.md
msgid "`network: xhttp`"
msgstr ""

#: src/protocols/xhttp.md
msgid "client/server"
msgstr ""

#: src/protocols/xhttp.md
msgid "Enables xHTTP transport."
msgstr "启用 xHTTP 传输。"

#: src/protocols/xhttp.md
msgid "`path`"
msgstr ""

#: src/protocols/xhttp.md
msgid "HTTP request path used by transport, must match on both sides."
msgstr "传输使用的 HTTP 请求路径，客户端与服务端必须一致。"

#: src/protocols/xhttp.md
msgid "`host`"
msgstr ""

#: src/protocols/xhttp.md
msgid "client"
msgstr ""

#: src/protocols/xhttp.md
msgid "Optional `Host` header override (for fronting/reverse proxy cases)."
msgstr "可选的 `Host` 请求头覆盖（用于前置/反向代理场景）。"

#: src/protocols/xhttp.md
msgid "`mode`"
msgstr ""

#: src/protocols/xhttp.md
msgid ""
"Transport mode, commonly `auto` (default) or platform-specific variants."
msgstr "传输模式，通常为 `auto`（默认）或平台特定变体。"

#: src/protocols/xhttp.md
msgid "`extra.headers`"
msgstr ""

#: src/protocols/xhttp.md
msgid "Extra HTTP headers to mimic app/API traffic."
msgstr "额外 HTTP 请求头，用于模拟应用/API 流量。"

#: src/protocols/xhttp.md
msgid "`xmux`"
msgstr ""

#: src/protocols/xhttp.md
msgid "Multiplex tuning such as concurrency limits and connection reuse."
msgstr "多路复用调优项，如并发限制与连接复用。"

#: src/protocols/xhttp.md
msgid "`tls` / `reality`"
msgstr ""

#: src/protocols/xhttp.md
msgid "Encryption/camouflage layer strongly recommended in production."
msgstr "生产环境强烈建议启用加密/伪装层。"

#: src/protocols/xhttp.md
msgid "Minimal Example (Client, Clash-Meta style)"
msgstr "最小示例（客户端，Clash-Meta 风格）"

#: src/protocols/xhttp.md
msgid "proxies"
msgstr ""

#: src/protocols/xhttp.md
msgid "name"
msgstr ""

#: src/protocols/xhttp.md
msgid "vless-xhttp"
msgstr ""

#: src/protocols/xhttp.md
msgid "vless"
msgstr ""

#: src/protocols/xhttp.md
msgid "server"
msgstr ""

#: src/protocols/xhttp.md
msgid "edge.example.com"
msgstr ""

#: src/protocols/xhttp.md
msgid "uuid"
msgstr ""

#: src/protocols/xhttp.md
msgid "11111111-2222-3333-4444-555555555555"
msgstr ""

#: src/protocols/xhttp.md
msgid "tls"
msgstr ""

#: src/protocols/xhttp.md
msgid "servername"
msgstr ""

#: src/protocols/xhttp.md
msgid "cdn.example.com"
msgstr ""

#: src/protocols/xhttp.md
msgid "network"
msgstr ""

#: src/protocols/xhttp.md
msgid "xhttp"
msgstr ""

#: src/protocols/xhttp.md
msgid "xhttp-opts"
msgstr ""

#: src/protocols/xhttp.md
msgid "/api/v1/sync"
msgstr ""

#: src/protocols/xhttp.md
msgid "host"
msgstr ""

#: src/protocols/xhttp.md
msgid "mode"
msgstr ""

#: src/protocols/xhttp.md
msgid "auto"
msgstr ""

#: src/protocols/xhttp.md
msgid "headers"
msgstr ""

#: src/protocols/xhttp.md
msgid "User-Agent"
msgstr ""

#: src/protocols/xhttp.md
msgid "okhttp/4.12.0"
msgstr ""

#: src/protocols/xhttp.md
msgid "Minimal Example (Server, Xray style)"
msgstr "最小示例（服务端，Xray 风格）"

#: src/protocols/xhttp.md
msgid "\"inbounds\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"port\""
msgstr ""

#: src/protocols/xhttp.md
#, fuzzy
msgid "\"protocol\""
msgstr "协议"

#: src/protocols/xhttp.md
msgid "\"vless\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"settings\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"clients\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"id\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"11111111-2222-3333-4444-555555555555\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"decryption\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"none\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"streamSettings\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"network\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"xhttp\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"security\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"tls\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"tlsSettings\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"serverName\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"cdn.example.com\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"certificates\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"certificateFile\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"/etc/ssl/fullchain.pem\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"keyFile\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"/etc/ssl/privkey.pem\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"xhttpSettings\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"path\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"/api/v1/sync\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"mode\""
msgstr ""

#: src/protocols/xhttp.md
msgid "\"auto\""
msgstr ""

#: src/protocols/xhttp.md
msgid "Deployment Notes"
msgstr "部署注意事项"

#: src/protocols/xhttp.md
msgid ""
"Keep `path` and mode fully aligned between client and server, otherwise "
"handshakes fail."
msgstr "保持客户端与服务端 `path` 和 mode 完全一致，否则握手会失败。"

#: src/protocols/xhttp.md
msgid ""
"Prefer realistic but stable headers; frequently changing fingerprints can "
"hurt reliability."
msgstr "优先使用真实且稳定的请求头；频繁变更指纹会降低稳定性。"

#: src/protocols/xhttp.md
msgid ""
"If deploying behind Nginx/Caddy/CDN, ensure request buffering and timeout "
"limits fit long-lived proxy streams."
msgstr "若部署在 Nginx/Caddy/CDN 后方，请确保请求缓冲与超时限制适配长连接代理流。"

#: src/protocols/xhttp.md
msgid ""
"Start with conservative `xmux` values, then tune concurrency after observing"
" latency and upstream limits."
msgstr "先使用保守的 `xmux` 参数，待观察延迟与上游限制后再调高并发。"

#: src/protocols/xhttp.md
msgid ""
"`EOF` immediately after connect: verify UUID, TLS server name, and `path` "
"consistency."
msgstr "连接后立即出现 `EOF`：请检查 UUID、TLS server name 以及 `path` 是否一致。"

#: src/protocols/xhttp.md
msgid ""
"Frequent reconnects: check reverse proxy idle timeout and HTTP/2 upstream "
"settings."
msgstr "频繁重连：请检查反向代理空闲超时和 HTTP/2 上游设置。"

#: src/protocols/xhttp.md
msgid ""
"Good handshake but poor throughput: reduce header bloat, tune `xmux`, and "
"verify CDN region affinity."
msgstr "握手正常但吞吐差：请减少请求头冗余、调优 `xmux`，并确认 CDN 区域亲和性。"

#: src/protocols/reality.md
msgid ""
"TLS camouflage layer from the Xray ecosystem that imitates a TLS 1.3 "
"handshake without issuing a certificate."
msgstr ""

#: src/protocols/reality.md
msgid ""
"Uses a server public key and short ID to bind the handshake to a real-"
"looking TLS fingerprint."
msgstr ""

#: src/protocols/reality.md
msgid ""
"Commonly paired with VLESS or Trojan to provide authentication and routing "
"on top of the transport."
msgstr ""

#: src/protocols/reality.md
msgid ""
"Client selects a cover domain and configures the server public key + short "
"ID."
msgstr ""

#: src/protocols/reality.md
msgid ""
"Client initiates a TLS 1.3-like handshake (uTLS fingerprint) with SNI set to"
" the cover domain."
msgstr ""

#: src/protocols/reality.md
#, fuzzy
msgid "Server validates the short ID and key exchange to accept the session."
msgstr "服务器校验密码与请求，然后连接到目标。"

#: src/protocols/reality.md
msgid ""
"On success, the connection upgrades to the chosen proxy protocol (for "
"example VLESS)."
msgstr ""

#: src/protocols/reality.md
msgid ""
"Avoids certificate issuance and rotation while keeping TLS-like handshake "
"behavior."
msgstr ""

#: src/protocols/reality.md
msgid ""
"Harder to fingerprint via passive inspection when the TLS client fingerprint"
" matches common browsers."
msgstr ""

#: src/protocols/reality.md
msgid "Integrates with XTLS flow control for reduced overhead."
msgstr ""

#: src/protocols/reality.md
msgid ""
"Requires compatible client fingerprints; mismatches can break connectivity."
msgstr ""

#: src/protocols/reality.md
msgid "Mostly confined to the Xray tooling ecosystem."
msgstr ""

#: src/protocols/reality.md
msgid ""
"Effectiveness depends on the chosen cover domain and correct configuration."
msgstr ""

#~ msgid ""
#~ "The landscape of proxy applications has become crowded and fragmented, "
#~ "so—out of personal interest—I decided to consolidate the ones I use into a "
#~ "single stack. The `chimera_client` takes inspiration from the open-source "
#~ "[clash-rs](https://github.com/Watfaq/clash-rs) project, with the long-term "
#~ "goal of matching [Mihomo](https://github.com/MetaCubeX/mihomo)'s feature "
#~ "set. `Chimera` follows the [clash-"
#~ "nyanpasu](https://github.com/libnyanpasu/clash-nyanpasu) project, but the "
#~ "key difference is that my top priority is first-class support for the "
#~ "`chimera_client` engine itself, which can largely be considered the `clash-"
#~ "rs` core. Meanwhile, the `chimera_server` project can be viewed as a Rust "
#~ "implementation of [xray-core](https://github.com/XTLS/Xray-core), with "
#~ "compatibility with the original `xray-core` remaining the end goal."
#~ msgstr ""
#~ "代理应用的生态日益拥挤且碎片化，因此出于个人兴趣，我决定将自己使用的方案整合为一个统一的技术栈。`chimera_client` 受到开源项目 "
#~ "[clash-rs](https://github.com/Watfaq/clash-rs) 启发，长期目标是对齐 "
#~ "[Mihomo](https://github.com/MetaCubeX/mihomo) 的功能集。`Chimera` 借鉴 [clash-"
#~ "nyanpasu](https://github.com/libnyanpasu/clash-nyanpasu) 项目，但关键区别在于我优先保障对 "
#~ "`chimera_client` 引擎的一流支持，它在很大程度上可视为 `clash-rs` 的核心。与此同时，`chimera_server` "
#~ "项目可以视作 [xray-core](https://github.com/XTLS/Xray-core) 的 Rust 实现，最终目标仍是与原版 "
#~ "`xray-core` 兼容。"

#~ msgid ""
#~ "Uses TLS as the outer layer; the first payload is a simple password-based "
#~ "handshake."
#~ msgstr "以 TLS 作为外层；首个负载是基于密码的简单握手。"

#~ msgid ""
#~ "Designed to look like normal HTTPS while granting full-duplex streams after "
#~ "auth."
#~ msgstr "设计为看起来像普通 HTTPS，认证后提供全双工流。"

#~ msgid "Commonly deployed alongside CDN fronting with SNI-based routing."
#~ msgstr "常与基于 SNI 路由的 CDN 前置一起部署。"

#~ msgid ""
#~ "Client performs a TLS handshake to the Trojan server using a legitimate SNI."
#~ msgstr "客户端使用合法 SNI 与 Trojan 服务器进行 TLS 握手。"

#~ msgid ""
#~ "Both sides exchange data within the encrypted TLS channel until termination."
#~ msgstr "双方在加密的 TLS 通道中交换数据直至结束。"

#~ msgid ""
#~ "Leverages well-tested TLS stacks; inherits forward secrecy and ALPN "
#~ "capabilities."
#~ msgstr "利用成熟的 TLS 栈，继承前向保密与 ALPN 能力。"

#~ msgid "Simple credential model makes operational management straightforward."
#~ msgstr "简单的凭证模型使运维管理更直接。"

#~ msgid ""
#~ "Can multiplex multiple users through one TLS endpoint while staying "
#~ "indistinguishable from HTTPS."
#~ msgstr "可在单个 TLS 端点上复用多用户，同时仍难以与 HTTPS 区分。"

#~ msgid ""
#~ "Each password maps to a virtual user; revocation requires redeploying "
#~ "configs."
#~ msgstr "每个密码对应一个虚拟用户；撤销需要重新下发配置。"

#~ msgid "TLS certificate management (issuance, renewal) is mandatory."
#~ msgstr "必须进行 TLS 证书管理（签发、续期）。"

#~ msgid ""
#~ "Middleboxes that block unknown ALPNs may require tweaking to match "
#~ "mainstream HTTPS fingerprints."
#~ msgstr "若中间设备阻断未知 ALPN，可能需要调整以匹配主流 HTTPS 指纹。"

#~ msgid ""
#~ "QUIC- and UDP-based transport built for high-throughput and high-latency "
#~ "networks."
#~ msgstr "面向高吞吐、高延迟网络的 QUIC/UDP 传输。"

#~ msgid ""
#~ "Implements selective acknowledgments, BBR-like congestion control, and "
#~ "application-layer keepalives."
#~ msgstr "实现选择性确认、类 BBR 拥塞控制以及应用层保活。"

#~ msgid "Supports protocol obfuscation by randomizing packet size/padding."
#~ msgstr "通过随机化包大小/填充支持协议混淆。"

#~ msgid ""
#~ "Client initiates a QUIC handshake to the server UDP port (default 443/udp)."
#~ msgstr "客户端对服务器 UDP 端口发起 QUIC 握手（默认 443/udp）。"

#~ msgid ""
#~ "TLS 1.3 handshake with ALPN `h3` runs inside QUIC; server authenticates via "
#~ "password or token."
#~ msgstr "带 ALPN `h3` 的 TLS 1.3 握手在 QUIC 内进行；服务器通过密码或令牌认证。"

#~ msgid ""
#~ "Adaptive congestion algorithm tunes pacing; optional packet loss recovery "
#~ "retransmits as needed."
#~ msgstr "自适应拥塞算法调整发送节奏；可选丢包恢复按需重传。"

#~ msgid ""
#~ "Excels on lossy or long-distance links thanks to optimized congestion "
#~ "control."
#~ msgstr "凭借优化的拥塞控制，在高丢包或长距离链路上表现出色。"

#~ msgid "Native UDP tunneling avoids TCP-over-TCP meltdown for gaming or VoIP."
#~ msgstr "原生 UDP 隧道避免游戏或 VoIP 场景的 TCP-over-TCP 崩溃。"

#~ msgid "Built-in obfuscation and padding resist simple traffic fingerprinting."
#~ msgstr "内置混淆与填充抵抗简单流量指纹。"

#~ msgid ""
#~ "Needs path MTU tuning to avoid fragmentation; 1200 bytes is a safe default."
#~ msgstr "需要进行路径 MTU 调优以避免分片；1200 字节是较安全的默认值。"

#~ msgid ""
#~ "Implementations are newer compared with SOCKS5/HTTP, so client compatibility"
#~ " is narrower."
#~ msgstr "相较 SOCKS5/HTTP，其实现较新，客户端兼容性更窄。"

#~ msgid "THis book"
#~ msgstr "这本书"

#: src/chimera/service-mode.md
msgid "Service Mode Configuration"
msgstr "服务模式配置"

#: src/chimera/service-mode.md
msgid "Scope and Intent"
msgstr "范围与意图"

#: src/chimera/service-mode.md
msgid ""
"In Chimera GUI, service mode runs the proxy core as a background system "
"service while the GUI acts as the control surface. This separation is "
"important when you need stable long-running behavior, elevated networking "
"privileges, or startup-before-login workflows."
msgstr ""
"在 Chimera GUI 中，服务模式会将代理核心作为后台系统服务运行，而 GUI 作为控制界面。"
"当你需要稳定的长期运行能力、更高的网络权限，或登录前启动的工作流时，这种分离非常重要。"

#: src/chimera/service-mode.md
msgid "Foreground Mode vs Service Mode"
msgstr "前台模式 vs 服务模式"

#: src/chimera/service-mode.md
msgid "Mode"
msgstr "模式"

#: src/chimera/service-mode.md
msgid "Runtime shape"
msgstr "运行形态"

#: src/chimera/service-mode.md
msgid "Typical use"
msgstr "典型用途"

#: src/chimera/service-mode.md
msgid "Main limitation"
msgstr "主要限制"

#: src/chimera/service-mode.md
msgid "Foreground mode"
msgstr "前台模式"

#: src/chimera/service-mode.md
msgid "GUI process owns the core directly"
msgstr "由 GUI 进程直接持有核心"

#: src/chimera/service-mode.md
msgid "Development and quick profile checks"
msgstr "开发与快速配置检查"

#: src/chimera/service-mode.md
msgid "Core stops when GUI exits or user logs out"
msgstr "当 GUI 退出或用户注销时，核心会停止"

#: src/chimera/service-mode.md
msgid "Service mode"
msgstr "服务模式"

#: src/chimera/service-mode.md
msgid ""
"System service owns the core; GUI controls it via local IPC"
msgstr "系统服务持有核心；GUI 通过本地 IPC 对其进行控制"

#: src/chimera/service-mode.md
msgid "Daily use, TUN/transparent routing, always-on setups"
msgstr "日常使用、TUN/透明路由、常驻在线场景"

#: src/chimera/service-mode.md
msgid "Requires service install and permission management"
msgstr "需要安装服务并管理权限"

#: src/chimera/service-mode.md
msgid "Why Enable Service Mode"
msgstr "为什么启用服务模式"

#: src/chimera/service-mode.md
msgid "Keep traffic forwarding alive even if the GUI is closed."
msgstr "即使 GUI 关闭，也能保持流量转发继续运行。"

#: src/chimera/service-mode.md
msgid ""
"Start proxy service automatically at boot/login with predictable lifecycle."
msgstr "在开机/登录时自动启动代理服务，并保持可预期的生命周期。"

#: src/chimera/service-mode.md
msgid ""
"Support privileged paths (for example TUN, policy routing, transparent "
"capture) more reliably."
msgstr "更可靠地支持特权路径（例如 TUN、策略路由、透明捕获）。"

#: src/chimera/service-mode.md
msgid "Reduce behavior drift across user sessions on shared machines."
msgstr "减少共享机器上不同用户会话之间的行为漂移。"

#: src/chimera/service-mode.md
msgid "Configuration Workflow in Chimera GUI"
msgstr "Chimera GUI 中的配置流程"

#: src/chimera/service-mode.md
msgid "Prepare and validate your active profile in normal mode first."
msgstr "先在普通模式下准备并验证当前启用的配置。"

#: src/chimera/service-mode.md
msgid "Open Chimera GUI settings and enable service mode."
msgstr "打开 Chimera GUI 设置并启用服务模式。"

#: src/chimera/service-mode.md
msgid "Install/register the service when prompted by the GUI."
msgstr "在 GUI 提示时安装/注册服务。"

#: src/chimera/service-mode.md
msgid "Choose startup policy:"
msgstr "选择启动策略："

#: src/chimera/service-mode.md
msgid "Manual: start only when needed."
msgstr "手动：仅在需要时启动。"

#: src/chimera/service-mode.md
msgid "Automatic: start at system boot (recommended for always-on use)."
msgstr "自动：系统启动时即启动（推荐用于常驻在线场景）。"

#: src/chimera/service-mode.md
msgid "Apply settings and trigger a service restart from the GUI."
msgstr "应用设置并在 GUI 中触发服务重启。"

#: src/chimera/service-mode.md
msgid ""
"Confirm the GUI can reconnect to the local control endpoint after restart."
msgstr "确认重启后 GUI 能重新连接本地控制端点。"

#: src/chimera/service-mode.md
msgid "Key Options and Recommended Defaults"
msgstr "关键选项与推荐默认值"

#: src/chimera/service-mode.md
msgid ""
"Option labels may vary slightly by platform/build, but the intent is usually"
" the same:"
msgstr "选项名称会因平台/构建略有差异，但含义通常一致："

#: src/chimera/service-mode.md
msgid "GUI option (common naming)"
msgstr "GUI 选项（常见命名）"

#: src/chimera/service-mode.md
msgid "Suggested default"
msgstr "建议默认值"

#: src/chimera/service-mode.md
msgid "`Enable Service Mode`"
msgstr "`Enable Service Mode`"

#: src/chimera/service-mode.md
msgid "Switch core runtime ownership to system service"
msgstr "将核心运行时归属切换为系统服务"

#: src/chimera/service-mode.md
msgid "On for long-term daily usage"
msgstr "长期日常使用建议开启"

#: src/chimera/service-mode.md
msgid "`Install/Repair Service`"
msgstr "`Install/Repair Service`"

#: src/chimera/service-mode.md
msgid "Register or repair service metadata"
msgstr "注册或修复服务元数据"

#: src/chimera/service-mode.md
msgid "Run after first enable and after upgrades"
msgstr "首次启用后以及升级后执行"

#: src/chimera/service-mode.md
msgid "`Start Service at Boot`"
msgstr "`Start Service at Boot`"

#: src/chimera/service-mode.md
msgid "Auto-start service during system startup"
msgstr "系统启动期间自动启动服务"

#: src/chimera/service-mode.md
msgid "On for TUN or gateway-style setups"
msgstr "TUN 或网关式部署建议开启"

#: src/chimera/service-mode.md
msgid "`Keep Running After GUI Exit`"
msgstr "`Keep Running After GUI Exit`"

#: src/chimera/service-mode.md
msgid "Leave service active when GUI closes"
msgstr "GUI 关闭后保持服务运行"

#: src/chimera/service-mode.md
msgid "On"
msgstr "开启"

#: src/chimera/service-mode.md
msgid "`Require Elevation on Apply`"
msgstr "`Require Elevation on Apply`"

#: src/chimera/service-mode.md
msgid ""
"Prompt for admin/root rights when applying privileged changes"
msgstr "在应用特权更改时提示获取管理员/root 权限"

#: src/chimera/service-mode.md
msgid "`Auto Recover on Crash`"
msgstr "`Auto Recover on Crash`"

#: src/chimera/service-mode.md
msgid "Restart service process after abnormal exit"
msgstr "异常退出后重启服务进程"

#: src/chimera/service-mode.md
msgid "Platform Notes"
msgstr "平台说明"

#: src/chimera/service-mode.md
msgid "Windows"
msgstr "Windows"

#: src/chimera/service-mode.md
msgid ""
"Service mode is usually backed by Windows Service Control Manager."
msgstr "服务模式通常由 Windows 服务控制管理器（SCM）支撑。"

#: src/chimera/service-mode.md
msgid "Use an elevated shell for first-time install/repair if GUI prompts fail."
msgstr "若 GUI 提示失败，首次安装/修复请使用提权终端执行。"

#: src/chimera/service-mode.md
msgid "Verify state with:"
msgstr "使用以下命令验证状态："

#: src/chimera/service-mode.md
msgid "Linux"
msgstr "Linux"

#: src/chimera/service-mode.md
msgid ""
"Service mode is typically managed by `systemd` (`chimera.service` or similar "
"unit name)."
msgstr "服务模式通常由 `systemd` 管理（`chimera.service` 或类似单元名）。"

#: src/chimera/service-mode.md
msgid ""
"Prefer explicit restart after profile changes that affect TUN/routing "
"behavior."
msgstr "对于会影响 TUN/路由行为的配置变更，建议显式重启服务。"

#: src/chimera/service-mode.md
msgid "macOS"
msgstr "macOS"

#: src/chimera/service-mode.md
msgid ""
"Service mode is usually implemented through `launchd` (system daemon style)."
msgstr "服务模式通常通过 `launchd` 实现（系统守护进程方式）。"

#: src/chimera/service-mode.md
msgid ""
"Ensure GUI and service binaries come from the same build channel/version."
msgstr "确保 GUI 与服务二进制来自同一构建渠道/版本。"

#: src/chimera/service-mode.md
msgid "Rollout Strategy"
msgstr "上线策略"

#: src/chimera/service-mode.md
msgid ""
"Start with SOCKS/listener-only profile and confirm baseline connectivity."
msgstr "先从仅 SOCKS/监听器配置开始，并确认基线连通性。"

#: src/chimera/service-mode.md
msgid "Enable service mode and verify reconnect behavior after GUI restart."
msgstr "启用服务模式，并验证 GUI 重启后的重连行为。"

#: src/chimera/service-mode.md
msgid ""
"Enable advanced options (TUN, DNS hijack, transparent capture) "
"incrementally."
msgstr "逐步启用高级选项（TUN、DNS 劫持、透明捕获）。"

#: src/chimera/service-mode.md
msgid ""
"Reboot once and verify auto-start, rule hit behavior, and DNS resolution "
"stability."
msgstr "重启一次，并验证自启动、规则命中行为以及 DNS 解析稳定性。"

#: src/chimera/service-mode.md
msgid "Symptom"
msgstr "现象"

#: src/chimera/service-mode.md
msgid "Likely cause"
msgstr "可能原因"

#: src/chimera/service-mode.md
msgid "Fix"
msgstr "修复方法"

#: src/chimera/service-mode.md
msgid "Service cannot start"
msgstr "服务无法启动"

#: src/chimera/service-mode.md
msgid "Missing admin/root privileges"
msgstr "缺少管理员/root 权限"

#: src/chimera/service-mode.md
msgid "Reinstall/repair service with elevation"
msgstr "以提权方式重新安装/修复服务"

#: src/chimera/service-mode.md
msgid "GUI shows \"disconnected from core\""
msgstr "GUI 显示“disconnected from core”"

#: src/chimera/service-mode.md
msgid "Control endpoint mismatch or service crash loop"
msgstr "控制端点不匹配或服务崩溃循环"

#: src/chimera/service-mode.md
msgid "Reapply service settings and inspect service logs"
msgstr "重新应用服务设置并检查服务日志"

#: src/chimera/service-mode.md
msgid "TUN features do not take effect"
msgstr "TUN 功能未生效"

#: src/chimera/service-mode.md
msgid "Service running but privileged route setup failed"
msgstr "服务在运行，但特权路由配置失败"

#: src/chimera/service-mode.md
msgid "Check system logs and permission/capability grants"
msgstr "检查系统日志与权限/能力授权"

#: src/chimera/service-mode.md
msgid "Profile changes seem ignored"
msgstr "配置变更看似未生效"

#: src/chimera/service-mode.md
msgid "GUI saved config but service did not reload"
msgstr "GUI 已保存配置，但服务未重载"

#: src/chimera/service-mode.md
msgid "Trigger explicit service restart from GUI"
msgstr "在 GUI 中显式触发服务重启"

#: src/chimera/service-mode.md
msgid "Traffic stops after logout"
msgstr "注销后流量中断"

#: src/chimera/service-mode.md
msgid "Foreground mode still active"
msgstr "前台模式仍在运行"

#: src/chimera/service-mode.md
msgid "Recheck that service mode is enabled and installed"
msgstr "重新确认服务模式已启用并完成安装"

#: src/chimera/service-mode.md
msgid "Operational Boundary"
msgstr "运行边界"

#: src/chimera/service-mode.md
msgid ""
"Service mode changes process lifecycle and permission model, not proxy policy"
" semantics."
msgstr "服务模式改变的是进程生命周期和权限模型，而不是代理策略语义。"

#: src/chimera/service-mode.md
msgid ""
"Your rules, DNS strategy, and outbound definitions are still determined by "
"the active Chimera profile."
msgstr "你的规则、DNS 策略和出站定义仍由当前生效的 Chimera 配置决定。"
